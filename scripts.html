<script>
    const SESSION = <?!= JSON.stringify(session) ?>;
  </script>
<script>
    (function () {
      const hasServer = typeof google !== 'undefined' && google.script && google.script.run;
      const server = hasServer ? google.script.run : null;
      const REQUEST_KEYS = ['supplies', 'it', 'maintenance'];
      const DASHBOARD_COLORS = {
        supplies: '#0b57d0',
        it: '#0f9d58',
        maintenance: '#f29900'
      };
      const NOTE_SUPPORTED_TYPES = new Set(['it', 'maintenance']);
      const HIDE_ETA_STATUSES = new Set(['denied', 'declined']);
      const CLOSED_REQUEST_STATES = new Set(['completed', 'closed', 'denied', 'declined', 'canceled', 'cancelled']);
      const URGENCY_SORT_ORDER = Object.freeze({ critical: 0, normal: 1, low: 2 });
      const DASHBOARD_REFRESH_INTERVAL = 60000;
      const DASHBOARD_DEBOUNCE = 500;
      const PERSIST_DELAY = 240;
      const persistTimers = {};
      let warmScheduled = false;
      let catalogWarmScheduled = false;
      let catalogWarmInFlight = false;
      let syncingCatalogToDescription = false;
      let dashboardAutoRefreshId = null;
      let dashboardDeferredRefreshId = null;
      const FORM_TEMPLATES = {
        supplies: { description: '', qty: 1, notes: '', catalogSku: '', location: '', requesterName: '', plantConfirmed: false },
        it: { location: '', issue: '', device: '', urgency: 'normal', details: '', requesterName: '' },
        maintenance: { location: '', issue: '', urgency: 'normal', accessNotes: '', requesterName: '' }
      };
      const LOCAL_KEYS = {
        supplies: 'request-manager:supplies',
        it: 'request-manager:it',
        maintenance: 'request-manager:maintenance'
      };
      const DEVICE_STORAGE_KEY = 'request-manager:device-id';
      const EMPTY_REQUEST_MESSAGES = {
        supplies: 'No supplies requests are pending right now.',
        it: 'No IT tickets are in the queue right now.',
        maintenance: 'No maintenance work orders are pending right now.'
      };
      const EMAIL_DISPLAY_OVERRIDES = Object.freeze({
        'skhun@dublincleaners.com': 'Sea Khun'
      });

      const state = {
        activeTab: 'supplies',
        forms: {
          supplies: Object.assign({}, FORM_TEMPLATES.supplies),
          it: Object.assign({}, FORM_TEMPLATES.it),
          maintenance: Object.assign({}, FORM_TEMPLATES.maintenance)
        },
        requesterName: '',
        deviceId: '',
        requests: {
          supplies: [],
          it: [],
          maintenance: []
        },
        noteDrafts: {
          it: {},
          maintenance: {}
        },
        nextTokens: {
          supplies: '',
          it: '',
          maintenance: ''
        },
        loading: {
          supplies: false,
          it: false,
          maintenance: false
        },
        loaded: {
          supplies: false,
          it: false,
          maintenance: false
        },
        catalog: {
          items: [],
          nextToken: '',
          loading: false,
          backgroundLoading: false,
          search: '',
          fullyLoaded: false,
          itemBySku: Object.create(null),
          descriptionIndex: Object.create(null),
          topSkuLookup: Object.create(null)
        },
        dashboard: {
          loading: false,
          metrics: makeEmptyDashboardMetrics(),
          totals: {
            totalRequests: 0,
            outstandingRequests: 0
          },
          insights: {
            supplies: [],
            itMaintenance: []
          },
          generatedAt: ''
        }
      };

      const dom = {
        tabButtons: Array.from(document.querySelectorAll('[data-tab-trigger]')),
        panels: Array.from(document.querySelectorAll('[data-tab-panel]')),
        tabAnchors: {
          supplies: document.getElementById('suppliesFormCard'),
          it: document.getElementById('itFormCard'),
          maintenance: document.getElementById('maintenanceFormCard')
        },
        statusNotice: document.getElementById('statusAuthNotice'),
        toast: document.getElementById('toast'),
        supplies: {
          form: document.getElementById('suppliesForm'),
          location: document.getElementById('suppliesLocation'),
          qty: document.getElementById('suppliesQty'),
          notes: document.getElementById('suppliesNotes'),
          description: document.getElementById('suppliesDescription'),
          requesterName: document.getElementById('suppliesRequesterName'),
          requesterNameRow: document.querySelector('[data-name-field="supplies"]'),
          submit: document.getElementById('suppliesSubmitButton'),
          reset: document.getElementById('suppliesResetButton'),
          list: document.getElementById('suppliesRequestsList'),
          more: document.getElementById('suppliesMoreButton'),
          catalogSearch: document.getElementById('catalogSearch'),
          catalogOptions: document.getElementById('catalogOptions'),
          catalogSku: document.getElementById('catalogSkuField'),
          catalogList: document.getElementById('catalogList'),
          catalogMore: document.getElementById('catalogMoreButton'),
          catalogClear: document.getElementById('catalogClearButton'),
          catalogScroll: document.getElementById('catalogScrollButton'),
          plantCheck: document.getElementById('suppliesPlantCheck'),
          catalogCard: document.getElementById('catalogCard'),
          approverNotice: document.querySelector('[data-approver-notice="supplies"]')
        },
        it: {
          form: document.getElementById('itForm'),
          location: document.getElementById('itLocation'),
          issue: document.getElementById('itIssue'),
          device: document.getElementById('itDevice'),
          urgency: document.getElementById('itUrgency'),
          details: document.getElementById('itDetails'),
          requesterName: document.getElementById('itRequesterName'),
          requesterNameRow: document.querySelector('[data-name-field="it"]'),
          submit: document.getElementById('itSubmitButton'),
          reset: document.getElementById('itResetButton'),
          list: document.getElementById('itRequestsList'),
          more: document.getElementById('itMoreButton'),
          approverNotice: document.querySelector('[data-approver-notice="it"]')
        },
        maintenance: {
          form: document.getElementById('maintenanceForm'),
          location: document.getElementById('maintenanceLocation'),
          issue: document.getElementById('maintenanceIssue'),
          urgency: document.getElementById('maintenanceUrgency'),
          accessNotes: document.getElementById('maintenanceAccessNotes'),
          requesterName: document.getElementById('maintenanceRequesterName'),
          requesterNameRow: document.querySelector('[data-name-field="maintenance"]'),
          submit: document.getElementById('maintenanceSubmitButton'),
          reset: document.getElementById('maintenanceResetButton'),
          list: document.getElementById('maintenanceRequestsList'),
          more: document.getElementById('maintenanceMoreButton'),
          approverNotice: document.querySelector('[data-approver-notice="maintenance"]')
        },
        dashboard: {
          container: document.getElementById('heroDashboard'),
          updatedAt: document.getElementById('dashboardUpdatedAt'),
          empty: document.getElementById('dashboardEmptyMessage'),
          pie: document.getElementById('dashboardPie'),
          insights: {
            card: document.getElementById('topInsightsCard'),
            suppliesList: document.getElementById('topSuppliesByLocation'),
            suppliesEmpty: document.getElementById('topSuppliesEmpty'),
            technicalList: document.getElementById('topTechByLocation'),
            technicalEmpty: document.getElementById('topTechEmpty'),
            viewButtons: Array.from(document.querySelectorAll('[data-insights-view]')),
            modal: {
              container: document.getElementById('insightsModal'),
              card: document.getElementById('insightsModalCard'),
              body: document.getElementById('insightsModalBody'),
              empty: document.getElementById('insightsModalEmpty'),
              title: document.getElementById('insightsModalTitle'),
              description: document.getElementById('insightsModalDescription'),
              close: document.getElementById('insightsModalClose')
            }
          },
          metrics: REQUEST_KEYS.reduce((acc, type) => {
            acc[type] = {
              total: document.querySelector(`[data-dashboard-total="${type}"]`),
              outstanding: document.querySelector(`[data-dashboard-outstanding="${type}"]`),
              avgStart: document.querySelector(`[data-dashboard-avg-start="${type}"]`),
              avgStartWrapper: document.querySelector(`[data-dashboard-avg-start-wrapper="${type}"]`),
              avgCompletion: document.querySelector(`[data-dashboard-avg-completion="${type}"]`),
              avgCompletionWrapper: document.querySelector(`[data-dashboard-avg-completion-wrapper="${type}"]`),
              deniedRatio: document.querySelector(`[data-dashboard-denied-ratio="${type}"]`),
              deniedRatioWrapper: document.querySelector(`[data-dashboard-denied-ratio-wrapper="${type}"]`)
            };
            return acc;
          }, {}),
          overall: {
            total: document.querySelector('[data-dashboard-total="all"]'),
            outstanding: document.querySelector('[data-dashboard-outstanding="all"]')
          }
        },
        feedback: {
          launcher: document.getElementById('feedbackLauncher'),
          dialog: document.getElementById('feedbackDialog'),
          form: document.getElementById('feedbackForm'),
          close: document.getElementById('feedbackCloseButton'),
          cancel: document.getElementById('feedbackCancelButton'),
          submit: document.getElementById('feedbackSubmitButton'),
          status: document.getElementById('feedbackStatus'),
          summary: document.getElementById('feedbackSummary'),
          details: document.getElementById('feedbackDetails'),
          contact: document.getElementById('feedbackContact'),
          chips: Array.from(document.querySelectorAll('.feedback-chip')),
          typeInputs: Array.from(document.querySelectorAll('input[name="feedbackType"]'))
        }
      };

      const initialLoadIndicator = createInitialLoadIndicator();
      if (initialLoadIndicator) {
        initialLoadIndicator.register('dashboard');
        initialLoadIndicator.register('requests:supplies');
        initialLoadIndicator.register('catalog');
      }

      const initialSessionEmail = SESSION && SESSION.email ? String(SESSION.email) : '';
      const canManageStatuses = Boolean(SESSION && SESSION.canManageStatuses);
      const requiresRequesterName = !initialSessionEmail;
      const statusAuth = SESSION && SESSION.statusAuth ? SESSION.statusAuth : null;
      const feedbackState = { open: false, submitting: false, closeTimer: null };
      const insightModalState = { open: false, type: 'supplies', trigger: null };

      renderStatusAuthNotice(statusAuth);
      configureRequesterNameRequirement();
      attachNavHandlers();
      attachFormHandlers();
      attachFeedbackHandlers();
      attachInsightHandlers();
      ensureDeviceId();
      REQUEST_KEYS.forEach(type => {
        hydrateFormFromCache(type);
      });
      initializeRequesterName();
      REQUEST_KEYS.forEach(type => {
        renderForm(type);
      });
      setActiveTab(state.activeTab);
      renderDashboard();
      if (hasServer) {
        loadDashboardMetrics({ silent: false });
        startDashboardAutoRefresh();
        loadCatalog({ append: false, fetchAll: false });
        ensureRequestsLoaded('supplies');
      } else {
        renderCatalog();
        REQUEST_KEYS.forEach(type => {
          state.loaded[type] = true;
          renderRequests(type);
        });
        showDashboardOfflineMessage();
        resolveInitialTask('dashboard');
        resolveInitialTask('requests:supplies');
        resolveInitialTask('catalog');
      }

      function loadDashboardMetrics(options) {
        if (!server) {
          state.dashboard.loading = false;
          renderDashboard();
          resolveInitialTask('dashboard');
          return;
        }
        const silent = Boolean(options && options.silent);
        if (!silent) {
          state.dashboard.loading = true;
          renderDashboard();
        }
        const payload = { cid: makeCid() };
        server
          .withSuccessHandler(response => {
            state.dashboard.loading = false;
            if (!response || !response.ok) {
              if (!silent) {
                handleError(response, 'getDashboardMetrics', payload);
              } else {
                console.error('[RequestManager]', 'getDashboardMetrics', response);
              }
              renderDashboard();
              return;
            }
            const metrics = makeEmptyDashboardMetrics();
            REQUEST_KEYS.forEach(type => {
              const entry = response.metrics && response.metrics[type] ? response.metrics[type] : null;
              const total = entry && Number(entry.total);
              const outstanding = entry && Number(entry.outstanding);
              const avgCompletionMs = entry && Number(entry.avgCompletionMs);
              const completionCount = entry && Number(entry.completionCount);
              const avgStartMs = entry && Number(entry.avgStartMs);
              const startCount = entry && Number(entry.startCount);
              const deniedCount = entry && Number(entry.deniedCount);
              const approvedCount = entry && Number(entry.approvedCount);
              metrics[type] = {
                total: Number.isFinite(total) && total > 0 ? total : 0,
                outstanding: Number.isFinite(outstanding) && outstanding > 0 ? outstanding : 0,
                avgCompletionMs: Number.isFinite(avgCompletionMs) && avgCompletionMs > 0 ? avgCompletionMs : 0,
                completionCount: Number.isFinite(completionCount) && completionCount > 0
                  ? Math.max(1, Math.round(completionCount))
                  : 0,
                avgStartMs: Number.isFinite(avgStartMs) && avgStartMs > 0 ? avgStartMs : 0,
                startCount: Number.isFinite(startCount) && startCount > 0
                  ? Math.max(1, Math.round(startCount))
                  : 0,
                deniedCount: Number.isFinite(deniedCount) && deniedCount >= 0
                  ? Math.max(0, Math.round(deniedCount))
                  : 0,
                approvedCount: Number.isFinite(approvedCount) && approvedCount >= 0
                  ? Math.max(0, Math.round(approvedCount))
                  : 0
              };
            });
            state.dashboard.metrics = metrics;
            const insightsResponse = response.insights || {};
            const suppliesTopEntries = Array.isArray(insightsResponse.suppliesTopByLocation)
              ? insightsResponse.suppliesTopByLocation.slice()
              : [];
            const suppliesAllEntries = Array.isArray(insightsResponse.suppliesAllByLocation)
              ? insightsResponse.suppliesAllByLocation.slice()
              : suppliesTopEntries.slice();
            const technicalTopEntries = Array.isArray(insightsResponse.itMaintenanceTopByLocation)
              ? insightsResponse.itMaintenanceTopByLocation.slice()
              : [];
            const technicalAllEntries = Array.isArray(insightsResponse.itMaintenanceAllByLocation)
              ? insightsResponse.itMaintenanceAllByLocation.slice()
              : technicalTopEntries.slice();
            state.dashboard.insights = {
              supplies: suppliesTopEntries,
              suppliesFull: suppliesAllEntries,
              itMaintenance: technicalTopEntries,
              itMaintenanceFull: technicalAllEntries
            };
            const totals = response.totals || {};
            const totalRequests = Number(totals.totalRequests);
            const outstandingRequests = Number(totals.outstandingRequests);
            state.dashboard.totals = {
              totalRequests: Number.isFinite(totalRequests) && totalRequests >= 0
                ? totalRequests
                : REQUEST_KEYS.reduce((sum, type) => sum + metrics[type].total, 0),
              outstandingRequests: Number.isFinite(outstandingRequests) && outstandingRequests >= 0
                ? outstandingRequests
                : REQUEST_KEYS.reduce((sum, type) => sum + metrics[type].outstanding, 0)
            };
            state.dashboard.generatedAt = typeof response.generatedAt === 'string' ? response.generatedAt : '';
            renderDashboard();
            resolveInitialTask('dashboard');
          })
          .withFailureHandler(err => {
            state.dashboard.loading = false;
            if (!silent) {
              handleError(err, 'getDashboardMetrics', payload);
            } else {
              console.error('[RequestManager]', 'getDashboardMetrics', err);
            }
            renderDashboard();
            resolveInitialTask('dashboard');
          })
          .getDashboardMetrics(payload);
      }

      function renderDashboard() {
        const container = dom.dashboard && dom.dashboard.container;
        if (!container) {
          return;
        }
        const loading = Boolean(state.dashboard.loading);
        const metrics = state.dashboard.metrics || makeEmptyDashboardMetrics();
        const totals = state.dashboard.totals || { totalRequests: 0, outstandingRequests: 0 };
        container.setAttribute('aria-busy', loading ? 'true' : 'false');
        if (dom.dashboard.overall.total) {
          dom.dashboard.overall.total.textContent = loading ? '…' : formatDashboardCount(totals.totalRequests || 0);
        }
        if (dom.dashboard.overall.outstanding) {
          dom.dashboard.overall.outstanding.textContent = loading ? '…' : formatDashboardCount(totals.outstandingRequests || 0);
        }
        REQUEST_KEYS.forEach(type => {
          const elements = dom.dashboard.metrics[type];
          const entry = metrics[type] || {
            total: 0,
            outstanding: 0,
            avgCompletionMs: 0,
            completionCount: 0,
            avgStartMs: 0,
            startCount: 0,
            deniedCount: 0,
            approvedCount: 0
          };
          const typeLabel = type === 'it' ? 'IT' : `${type.charAt(0).toUpperCase()}${type.slice(1)}`;
          const totalLabel = loading ? '…' : formatDashboardCount(entry.total);
          const outstandingLabel = loading ? '…' : formatDashboardCount(entry.outstanding);
          const hasCompletionData = !loading && Number(entry.completionCount) > 0;
          const averageLabel = loading
            ? '…'
            : hasCompletionData
              ? formatDashboardDuration(entry.avgCompletionMs)
              : '—';
          const hasStartData = !loading && Number(entry.startCount) > 0;
          const startLabel = loading
            ? '…'
            : hasStartData
              ? formatDashboardDuration(entry.avgStartMs)
              : '—';
          const deniedCount = loading ? 0 : Math.max(0, Number(entry.deniedCount) || 0);
          const approvedCount = loading ? 0 : Math.max(0, Number(entry.approvedCount) || 0);
          const hasRatioData = !loading && approvedCount > 0;
          const hasRatioHistory = !loading && (approvedCount > 0 || deniedCount > 0);
          const ratioLabel = loading
            ? '…'
            : hasRatioData
              ? formatDashboardRatio(deniedCount, approvedCount)
              : '—';
          if (elements) {
            if (elements.total) {
              elements.total.textContent = totalLabel;
            }
            if (elements.outstanding) {
              elements.outstanding.textContent = outstandingLabel;
            }
            if (elements.deniedRatio) {
              elements.deniedRatio.textContent = ratioLabel;
            }
            if (elements.deniedRatioWrapper) {
              if (loading) {
                elements.deniedRatioWrapper.dataset.state = 'loading';
                elements.deniedRatioWrapper.removeAttribute('title');
              } else if (hasRatioData) {
                elements.deniedRatioWrapper.dataset.state = 'ready';
                const deniedLabel = formatDashboardCount(deniedCount);
                const approvedLabel = formatDashboardCount(approvedCount);
                elements.deniedRatioWrapper.setAttribute(
                  'title',
                  `${deniedLabel} denied vs ${approvedLabel} approved ${typeLabel} requests.`
                );
              } else if (hasRatioHistory) {
                elements.deniedRatioWrapper.dataset.state = 'empty';
                elements.deniedRatioWrapper.setAttribute('title', `No approved ${typeLabel} requests yet.`);
              } else {
                elements.deniedRatioWrapper.dataset.state = 'empty';
                elements.deniedRatioWrapper.setAttribute('title', `No reviewed ${typeLabel} requests yet.`);
              }
            }
            if (elements.avgStart) {
              elements.avgStart.textContent = startLabel;
            }
            if (elements.avgStartWrapper) {
              if (loading) {
                elements.avgStartWrapper.dataset.state = 'loading';
                elements.avgStartWrapper.removeAttribute('title');
              } else if (hasStartData) {
                elements.avgStartWrapper.dataset.state = 'ready';
                const startCountLabel = formatDashboardCount(entry.startCount);
                const startBasisText = Number(entry.startCount) === 1
                  ? 'Based on 1 started request.'
                  : `Based on ${startCountLabel} started requests.`;
                elements.avgStartWrapper.setAttribute('title', startBasisText);
              } else {
                elements.avgStartWrapper.dataset.state = 'empty';
                elements.avgStartWrapper.setAttribute('title', 'No started requests yet.');
              }
            }
            if (elements.avgCompletion) {
              elements.avgCompletion.textContent = averageLabel;
            }
            if (elements.avgCompletionWrapper) {
              if (loading) {
                elements.avgCompletionWrapper.dataset.state = 'loading';
                elements.avgCompletionWrapper.removeAttribute('title');
              } else if (hasCompletionData) {
                elements.avgCompletionWrapper.dataset.state = 'ready';
                const countLabel = formatDashboardCount(entry.completionCount);
                const basisText = Number(entry.completionCount) === 1
                  ? 'Based on 1 completed request.'
                  : `Based on ${countLabel} completed requests.`;
                elements.avgCompletionWrapper.setAttribute('title', basisText);
              } else {
                elements.avgCompletionWrapper.dataset.state = 'empty';
                elements.avgCompletionWrapper.setAttribute('title', 'No completed requests yet.');
              }
            }
          }
        });
        renderTopInsights(loading);
        updateDashboardEmptyState(metrics, loading);
        updateDashboardTimestamp();
        drawDashboardPie();
      }

      function renderTopInsights(loading) {
        const insightsDom = dom.dashboard && dom.dashboard.insights;
        if (!insightsDom || !insightsDom.card) {
          return;
        }
        const card = insightsDom.card;
        const insightsState = state.dashboard.insights || { supplies: [], itMaintenance: [] };
        const suppliesEntries = Array.isArray(insightsState.supplies) ? insightsState.supplies : [];
        const technicalEntries = Array.isArray(insightsState.itMaintenance) ? insightsState.itMaintenance : [];
        const offline = !hasServer;
        renderInsightList({
          list: insightsDom.suppliesList,
          empty: insightsDom.suppliesEmpty,
          entries: suppliesEntries,
          loading,
          limit: 5,
          formatter: buildSuppliesInsightRow,
          emptyMessage: offline
            ? 'Connect to Google Apps Script to load live data.'
            : 'No supplies requests yet.'
        });
        renderInsightList({
          list: insightsDom.technicalList,
          empty: insightsDom.technicalEmpty,
          entries: technicalEntries,
          loading,
          limit: 5,
          formatter: buildTechnicalInsightRow,
          emptyMessage: offline
            ? 'Connect to Google Apps Script to load live data.'
            : 'No IT or Maintenance requests yet.'
        });
        if (loading && !state.dashboard.generatedAt) {
          card.dataset.state = 'loading';
        } else if (!suppliesEntries.length && !technicalEntries.length) {
          card.dataset.state = 'empty';
        } else {
          card.dataset.state = 'ready';
        }
      }

      function renderInsightList(options) {
        const list = options && options.list ? options.list : null;
        if (!list) {
          return;
        }
        while (list.firstChild) {
          list.removeChild(list.firstChild);
        }
        const empty = options && options.empty ? options.empty : null;
        const limit = options && typeof options.limit === 'number' && Number.isFinite(options.limit) && options.limit > 0
          ? Math.floor(options.limit)
          : null;
        const loading = Boolean(options && options.loading);
        if (loading && !state.dashboard.generatedAt) {
          list.hidden = false;
          if (empty) {
            empty.hidden = true;
          }
          const placeholderCount = limit || 3;
          for (let i = 0; i < placeholderCount; i++) {
            const placeholder = document.createElement('li');
            placeholder.className = 'skeleton';
            placeholder.setAttribute('aria-hidden', 'true');
            list.appendChild(placeholder);
          }
          return;
        }
        const entries = Array.isArray(options && options.entries) ? options.entries : [];
        const data = limit ? entries.slice(0, limit) : entries.slice();
        if (!data.length) {
          list.hidden = true;
          if (empty) {
            if (typeof options.emptyMessage === 'string' && options.emptyMessage.trim()) {
              empty.textContent = options.emptyMessage;
            }
            empty.hidden = false;
          }
          return;
        }
        const fragment = document.createDocumentFragment();
        const formatter = typeof options.formatter === 'function' ? options.formatter : null;
        data.forEach(entry => {
          const item = formatter ? formatter(entry) : null;
          if (item) {
            fragment.appendChild(item);
          }
        });
        list.hidden = false;
        list.appendChild(fragment);
        if (empty) {
          empty.hidden = true;
        }
      }

      function abbreviateInsightCatalogItem(label, maxLength) {
        const fallbackLimit = 12;
        const normalizedLimit = Number.isFinite(maxLength) && maxLength > 0
          ? Math.max(6, Math.min(Math.floor(maxLength), fallbackLimit))
          : fallbackLimit;
        const normalized = typeof label === 'string' ? label.trim() : '';
        if (!normalized) {
          return '';
        }
        const truncated = normalized.slice(0, normalizedLimit);
        if (normalized.length <= normalizedLimit) {
          return truncated;
        }
        const words = truncated.split(/\s+/).filter(Boolean);
        if (words.length <= 1) {
          return `${truncated.trimEnd()}…`;
        }
        const firstWord = words[0];
        if (firstWord.length >= normalizedLimit - 1) {
          return `${firstWord.slice(0, Math.max(0, normalizedLimit - 1)).trimEnd()}…`;
        }
        let abbreviated = firstWord;
        for (let i = 1; i < words.length; i += 1) {
          const word = words[i];
          if (!word) {
            continue;
          }
          const short = word.length <= 3 ? word : `${word.charAt(0).toUpperCase()}.`;
          const next = `${abbreviated} ${short}`;
          if (next.length > normalizedLimit - 1) {
            break;
          }
          abbreviated = next;
        }
        if (abbreviated.length >= normalizedLimit - 1) {
          abbreviated = abbreviated.slice(0, normalizedLimit - 1).trimEnd();
        }
        return `${abbreviated}…`;
      }

      function buildSuppliesInsightRow(entry) {
        if (!entry) {
          return null;
        }
        const li = document.createElement('li');
        li.className = 'insight-row';
        const location = document.createElement('span');
        location.className = 'insight-location';
        const locationText = typeof entry.location === 'string' && entry.location.trim()
          ? entry.location.trim()
          : 'Unknown';
        location.textContent = locationText;
        const value = document.createElement('span');
        value.className = 'insight-value';
        const itemLabel = typeof entry.item === 'string' && entry.item.trim() ? entry.item.trim() : '—';
        const locationLength = locationText.length;
        const maxItemLength = locationLength >= 18
          ? 8
          : locationLength >= 14
            ? 9
            : locationLength >= 10
              ? 10
              : 12;
        const abbreviatedItemLabel = itemLabel === '—'
          ? itemLabel
          : abbreviateInsightCatalogItem(itemLabel, maxItemLength);
        const quantityValue = Number(entry.quantity);
        const hasQuantity = Number.isFinite(quantityValue) && quantityValue > 0;
        const quantityLabel = hasQuantity ? formatDashboardCount(quantityValue) : '0';
        value.textContent = hasQuantity ? `${abbreviatedItemLabel} (${quantityLabel})` : abbreviatedItemLabel;
        const tooltipParts = [];
        if (itemLabel && itemLabel !== '—') {
          tooltipParts.push(itemLabel);
        }
        if (entry.catalogSku && String(entry.catalogSku).trim()) {
          tooltipParts.push(`SKU ${String(entry.catalogSku).trim()}`);
        }
        if (hasQuantity) {
          const quantityTooltip = quantityValue === 1
            ? 'All-time quantity: 1 item requested'
            : `All-time quantity: ${quantityLabel} items requested`;
          tooltipParts.push(quantityTooltip);
        } else {
          tooltipParts.push('All-time quantity: 0 items requested');
        }
        const requestCount = Number(entry.requestCount);
        if (Number.isFinite(requestCount) && requestCount > 0) {
          const requestTooltip = requestCount === 1
            ? 'All-time: 1 request'
            : `All-time: ${formatDashboardCount(requestCount)} requests`;
          tooltipParts.push(requestTooltip);
        } else {
          tooltipParts.push('All-time: 0 requests');
        }
        if (tooltipParts.length) {
          const tooltipText = tooltipParts.join(' • ');
          value.title = tooltipText;
          value.setAttribute('aria-label', tooltipText);
        } else {
          value.removeAttribute('title');
          value.removeAttribute('aria-label');
        }
        li.appendChild(location);
        li.appendChild(value);
        return li;
      }

      function buildTechnicalInsightRow(entry) {
        if (!entry) {
          return null;
        }
        const li = document.createElement('li');
        li.className = 'insight-row';
        const location = document.createElement('span');
        location.className = 'insight-location';
        const locationText = typeof entry.location === 'string' && entry.location.trim()
          ? entry.location.trim()
          : 'Unknown';
        location.textContent = locationText;
        const value = document.createElement('span');
        value.className = 'insight-value';
        const total = Number(entry.count);
        const totalLabel = Number.isFinite(total) && total > 0 ? formatDashboardCount(total) : '0';
        const strong = document.createElement('strong');
        strong.textContent = totalLabel;
        value.appendChild(strong);
        value.appendChild(document.createTextNode(total === 1 ? ' request' : ' requests'));
        const tooltipParts = [
          total === 1 ? 'All-time total: 1 request' : `All-time total: ${totalLabel} requests`
        ];
        const itCount = Number(entry.itCount);
        if (Number.isFinite(itCount) && itCount > 0) {
          tooltipParts.push(
            itCount === 1
              ? 'IT: 1 request'
              : `IT: ${formatDashboardCount(itCount)} requests`
          );
        } else {
          tooltipParts.push('IT: 0 requests');
        }
        const maintenanceCount = Number(entry.maintenanceCount);
        if (Number.isFinite(maintenanceCount) && maintenanceCount > 0) {
          tooltipParts.push(
            maintenanceCount === 1
              ? 'Maintenance: 1 request'
              : `Maintenance: ${formatDashboardCount(maintenanceCount)} requests`
          );
        } else {
          tooltipParts.push('Maintenance: 0 requests');
        }
        if (tooltipParts.length) {
          const tooltipText = tooltipParts.join(' • ');
          value.title = tooltipText;
          value.setAttribute('aria-label', tooltipText);
        } else {
          value.removeAttribute('title');
          value.removeAttribute('aria-label');
        }
        li.appendChild(location);
        li.appendChild(value);
        return li;
      }

      function updateDashboardEmptyState(metrics, loading) {
        const empty = dom.dashboard && dom.dashboard.empty;
        if (!empty) {
          return;
        }
        if (!hasServer) {
          empty.hidden = false;
          empty.textContent = 'Connect to Google Apps Script to load live data.';
          return;
        }
        const hasRequests = REQUEST_KEYS.some(type => {
          const entry = metrics[type] || { total: 0 };
          return Number(entry.total) > 0;
        });
        if (!hasRequests) {
          empty.hidden = false;
          empty.textContent = loading && !state.dashboard.generatedAt ? 'Loading dashboard…' : 'No requests yet.';
          return;
        }
        empty.hidden = true;
      }

      function updateDashboardTimestamp() {
        const label = dom.dashboard && dom.dashboard.updatedAt;
        if (!label) {
          return;
        }
        if (!hasServer) {
          label.textContent = 'Offline preview';
          return;
        }
        if (state.dashboard.loading && !state.dashboard.generatedAt) {
          label.textContent = 'Loading…';
          return;
        }
        if (!state.dashboard.generatedAt) {
          label.textContent = 'Awaiting data…';
          return;
        }
        const timestamp = new Date(state.dashboard.generatedAt);
        if (!Number.isNaN(timestamp.getTime())) {
          label.textContent = `Updated ${timestamp.toLocaleString()}`;
        } else {
          label.textContent = 'Updated moments ago';
        }
      }

      function drawDashboardPie() {
        const canvas = dom.dashboard && dom.dashboard.pie;
        if (!canvas || typeof canvas.getContext !== 'function') {
          return;
        }
        const rect = canvas.getBoundingClientRect();
        const displayWidth = rect.width || canvas.width || 220;
        const displayHeight = rect.height || canvas.height || 220;
        const ratio = window.devicePixelRatio || 1;
        const targetWidth = Math.max(1, Math.round(displayWidth * ratio));
        const targetHeight = Math.max(1, Math.round(displayHeight * ratio));
        if (canvas.width !== targetWidth || canvas.height !== targetHeight) {
          canvas.width = targetWidth;
          canvas.height = targetHeight;
        }
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          return;
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (ratio !== 1) {
          ctx.scale(ratio, ratio);
        }
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        const metrics = state.dashboard.metrics || makeEmptyDashboardMetrics();
        const values = REQUEST_KEYS.map(type => {
          const entry = metrics[type] || { outstanding: 0 };
          const value = Number(entry.outstanding);
          return Number.isFinite(value) && value > 0 ? value : 0;
        });
        const total = values.reduce((sum, value) => sum + value, 0);
        const centerX = displayWidth / 2;
        const centerY = displayHeight / 2;
        const radius = Math.max(10, Math.min(centerX, centerY) - 6);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fillStyle = '#eef2f7';
        ctx.fill();
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#d7dce1';
        ctx.stroke();
        if (!total) {
          let successColor = '#0f9d58';
          if (typeof window !== 'undefined' && typeof window.getComputedStyle === 'function') {
            const rootStyles = window.getComputedStyle(document.documentElement);
            if (rootStyles) {
              const cssValue = rootStyles.getPropertyValue('--success');
              if (cssValue && cssValue.trim()) {
                successColor = cssValue.trim();
              }
            }
          }
          const markSize = radius * 0.65;
          ctx.strokeStyle = successColor;
          ctx.lineWidth = Math.max(6, radius * 0.2);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath();
          ctx.moveTo(centerX - markSize * 0.55, centerY + markSize * 0.05);
          ctx.lineTo(centerX - markSize * 0.1, centerY + markSize * 0.6);
          ctx.lineTo(centerX + markSize * 0.6, centerY - markSize * 0.45);
          ctx.stroke();
          return;
        }
        let startAngle = -Math.PI / 2;
        values.forEach((value, index) => {
          if (!value) {
            return;
          }
          const type = REQUEST_KEYS[index];
          const endAngle = startAngle + (value / total) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
          ctx.closePath();
          ctx.fillStyle = DASHBOARD_COLORS[type] || '#0b57d0';
          ctx.fill();
          startAngle = endAngle;
        });
        const innerRadius = Math.max(radius * 0.55, radius - 44);
        ctx.beginPath();
        ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        ctx.fillStyle = '#202731';
        ctx.font = '600 16px "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(formatDashboardCount(total), centerX, centerY - 8);
        ctx.font = '500 12px "Segoe UI", sans-serif';
        ctx.fillStyle = '#5c6774';
        ctx.fillText('outstanding', centerX, centerY + 10);
      }

      function formatDashboardCount(value) {
        const number = Number(value);
        if (!Number.isFinite(number)) {
          return '0';
        }
        return number.toLocaleString();
      }

      function formatDashboardDuration(ms) {
        const value = Number(ms);
        if (!Number.isFinite(value) || value <= 0) {
          return '—';
        }
        const minutes = value / 60000;
        if (minutes < 1) {
          return '<1 min';
        }
        if (minutes < 60) {
          const roundedMinutes = Math.max(1, Math.round(minutes));
          return `${roundedMinutes.toLocaleString()} min`;
        }
        const hours = minutes / 60;
        if (hours < 48) {
          return formatDashboardDurationLabel(hours, 'hr');
        }
        const days = hours / 24;
        return formatDashboardDurationLabel(days, 'day');
      }

      function formatDashboardDurationLabel(value, unit) {
        const normalized = Number(value);
        if (!Number.isFinite(normalized) || normalized <= 0) {
          return '—';
        }
        let display;
        if (normalized >= 10) {
          display = Math.round(normalized);
        } else {
          display = Math.round(normalized * 10) / 10;
        }
        const formatted = Number.isInteger(display)
          ? display.toLocaleString()
          : display.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 });
        const plural = Math.abs(display) === 1 ? '' : 's';
        return `${formatted} ${unit}${plural}`;
      }

      function formatDashboardRatio(denied, approved) {
        const deniedValue = Number(denied);
        const approvedValue = Number(approved);
        const deniedCount = Number.isFinite(deniedValue) ? Math.max(0, Math.round(deniedValue)) : 0;
        const approvedCount = Number.isFinite(approvedValue) ? Math.max(0, Math.round(approvedValue)) : 0;
        if (approvedCount === 0 && deniedCount === 0) {
          return '—';
        }
        if (deniedCount === 0 || approvedCount === 0) {
          return `${formatDashboardCount(deniedCount)} : ${formatDashboardCount(approvedCount)}`;
        }
        const divisor = greatestCommonDivisor(deniedCount, approvedCount);
        const left = deniedCount / divisor;
        const right = approvedCount / divisor;
        return `${formatDashboardCount(left)} : ${formatDashboardCount(right)}`;
      }

      function greatestCommonDivisor(a, b) {
        let x = Math.abs(Number(a)) || 0;
        let y = Math.abs(Number(b)) || 0;
        if (!Number.isFinite(x)) {
          x = 0;
        }
        if (!Number.isFinite(y)) {
          y = 0;
        }
        if (x === 0 && y === 0) {
          return 1;
        }
        while (y !== 0) {
          const temp = y;
          y = x % y;
          x = temp;
        }
        return x === 0 ? 1 : x;
      }

      function makeEmptyDashboardMetrics() {
        return REQUEST_KEYS.reduce((acc, type) => {
          acc[type] = {
            total: 0,
            outstanding: 0,
            avgCompletionMs: 0,
            completionCount: 0,
            avgStartMs: 0,
            startCount: 0,
            deniedCount: 0,
            approvedCount: 0
          };
          return acc;
        }, {});
      }

      function requestDashboardRefresh(delay) {
        if (!hasServer) {
          return;
        }
        const wait = typeof delay === 'number' && delay >= 0 ? delay : DASHBOARD_DEBOUNCE;
        if (dashboardDeferredRefreshId) {
          window.clearTimeout(dashboardDeferredRefreshId);
        }
        dashboardDeferredRefreshId = window.setTimeout(() => {
          dashboardDeferredRefreshId = null;
          loadDashboardMetrics({ silent: true });
        }, wait);
      }

      function startDashboardAutoRefresh() {
        if (!hasServer) {
          return;
        }
        stopDashboardAutoRefresh();
        dashboardAutoRefreshId = window.setInterval(() => {
          loadDashboardMetrics({ silent: true });
        }, DASHBOARD_REFRESH_INTERVAL);
      }

      function stopDashboardAutoRefresh() {
        if (dashboardAutoRefreshId) {
          window.clearInterval(dashboardAutoRefreshId);
          dashboardAutoRefreshId = null;
        }
        if (dashboardDeferredRefreshId) {
          window.clearTimeout(dashboardDeferredRefreshId);
          dashboardDeferredRefreshId = null;
        }
      }

      function showDashboardOfflineMessage() {
        const empty = dom.dashboard && dom.dashboard.empty;
        if (empty) {
          empty.hidden = false;
          empty.textContent = 'Connect to Google Apps Script to load live data.';
        }
        const label = dom.dashboard && dom.dashboard.updatedAt;
        if (label) {
          label.textContent = 'Offline preview';
        }
      }

      function clearApproverNotices() {
        REQUEST_KEYS.forEach(type => {
          const container = dom[type] && dom[type].approverNotice;
          if (!container) {
            return;
          }
          while (container.firstChild) {
            container.removeChild(container.firstChild);
          }
          delete container.dataset.variant;
          container.hidden = true;
        });
      }

function renderApproverUnavailable(auth) {
        const accountLabel = formatActorName(auth && auth.email) || 'This account';
        const messageText = auth && auth.reason === 'missing_email'
          ? 'We could not confirm your Google Account email. To Approve a Request, Sign in with an authorized account.'
          : `${accountLabel} is not on the approver allowlist.`;
        const hintText = 'An administrator can add approver emails.';
        REQUEST_KEYS.forEach(type => {
          const container = dom[type] && dom[type].approverNotice;
          if (!container) {
            return;
          }
          container.dataset.variant = 'warning';
          const title = document.createElement('strong');
          title.textContent = 'Approver access unavailable';
          container.appendChild(title);
          const message = document.createElement('p');
          message.textContent = messageText;
          container.appendChild(message);
          const hint = document.createElement('p');
          hint.textContent = hintText;
          container.appendChild(hint);
          container.hidden = false;
        });
      }

      function renderStatusAuthNotice(auth) {
        const notice = dom.statusNotice;
        if (notice) {
          while (notice.firstChild) {
            notice.removeChild(notice.firstChild);
          }
          delete notice.dataset.variant;
          notice.hidden = true;
        }
        clearApproverNotices();
        if (!auth) {
          return;
        }
        if (!auth.authorized) {
          renderApproverUnavailable(auth);
          return;
        }
        if (auth.allowlistSource === 'script_property' && notice) {
          notice.dataset.variant = 'info';
          const title = document.createElement('strong');
          title.textContent = 'Managed approver list active';
          notice.appendChild(title);
          const message = document.createElement('p');
          message.textContent = 'Approver permissions are being served from the SUPPLIES_TRACKING_STATUS_EMAILS script property fallback.';
          notice.appendChild(message);
          notice.hidden = false;
        }
      }

      function attachNavHandlers() {
        dom.tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            const type = button.getAttribute('data-tab-trigger');
            if (type && REQUEST_KEYS.indexOf(type) !== -1) {
              const shouldScroll = Boolean(button.closest('.hero-actions'));
              setActiveTab(type);
              if (shouldScroll) {
                window.requestAnimationFrame(() => {
                  scrollToTab(type);
                });
              }
            }
          });
        });
      }

      function scrollToTab(type) {
        const anchor = dom.tabAnchors && dom.tabAnchors[type];
        const nav = document.querySelector('.tab-nav');
        if (
          !anchor ||
          !nav ||
          typeof anchor.getBoundingClientRect !== 'function' ||
          typeof nav.getBoundingClientRect !== 'function'
        ) {
          return;
        }

        const navRect = nav.getBoundingClientRect();
        const navStyles = typeof window.getComputedStyle === 'function' ? window.getComputedStyle(nav) : null;
        const navSpacing = navStyles ? parseFloat(navStyles.marginBottom || '0') : 0;
        const navOffset = navRect.height + navSpacing;
        const extraSpacing = 16;
        const navSafePadding = 12;

        const anchorRect = anchor.getBoundingClientRect();
        const anchorTop = anchorRect.top + window.pageYOffset;
        const navTop = navRect.top + window.pageYOffset;

        const anchorTarget = anchorTop - navOffset - extraSpacing;
        const navTarget = navTop - navSafePadding;
        const targetTop = Math.max(Math.min(anchorTarget, navTarget), 0);

        window.scrollTo({ top: targetTop, behavior: 'smooth' });
      }

      function attachFormHandlers() {
        dom.supplies.form.addEventListener('submit', evt => handleSubmit(evt, 'supplies'));
        dom.supplies.reset.addEventListener('click', () => {
          resetForm('supplies');
        });
        dom.supplies.location.addEventListener('change', () => {
          setFormState('supplies', { location: dom.supplies.location.value });
          persistForm('supplies');
        });
        dom.supplies.qty.addEventListener('input', () => {
          const qty = Number(dom.supplies.qty.value);
          const sanitized = Number.isFinite(qty) && qty > 0 ? Math.floor(qty) : 1;
          setFormState('supplies', { qty: sanitized });
          dom.supplies.qty.value = sanitized;
          persistForm('supplies');
        });
        dom.supplies.notes.addEventListener('input', () => {
          setFormState('supplies', { notes: dom.supplies.notes.value });
          persistForm('supplies');
        });
        dom.supplies.description.addEventListener('input', () => {
          const value = dom.supplies.description.value || '';
          const trimmed = value.trim();
          if (!syncingCatalogToDescription) {
            let matchedSku = '';
            if (trimmed) {
              const match = findCatalogItemByDescription(trimmed);
              if (match) {
                matchedSku = makeCatalogSkuKey(match.sku);
              }
            }
            setFormState('supplies', { description: value, catalogSku: matchedSku });
            dom.supplies.catalogSku.value = matchedSku;
          } else {
            setFormState('supplies', { description: value });
          }
          persistForm('supplies');
          if (state.catalog.items.length) {
            renderCatalog();
          }
        });
        dom.supplies.catalogSearch.addEventListener('focus', () => {
          ensureFullCatalogLoaded();
          updateCatalogSearchAffordances();
        });
        dom.supplies.catalogSearch.addEventListener('click', () => {
          ensureFullCatalogLoaded();
        });
        if (dom.supplies.requesterName) {
          dom.supplies.requesterName.addEventListener('input', () => {
            handleRequesterNameInput('supplies');
          });
        }
        const handleCatalogSearchInput = () => {
          ensureFullCatalogLoaded();
          const rawValue = dom.supplies.catalogSearch.value || '';
          const previousSearch = state.catalog.search;
          const previousSku = makeCatalogSkuKey(state.forms.supplies.catalogSku || '');
          state.catalog.search = rawValue;
          const option = findCatalogOption(rawValue);
          if (option) {
            selectCatalogSku(option.dataset ? option.dataset.sku || '' : '', { searchValue: rawValue, updateSearch: false });
          } else {
            selectCatalogSku('', { searchValue: rawValue, updateSearch: false, preserveDescription: true });
          }
          const currentSku = makeCatalogSkuKey(state.forms.supplies.catalogSku || '');
          const skuChanged = currentSku !== previousSku;
          const searchChanged = rawValue !== previousSearch;
          const hasItems = state.catalog.items.length > 0;
          if ((hasItems && (searchChanged || skuChanged)) || (!hasItems && searchChanged)) {
            renderCatalog();
          }
          updateCatalogSearchAffordances();
        };
        dom.supplies.catalogSearch.addEventListener('input', handleCatalogSearchInput);
        dom.supplies.catalogSearch.addEventListener('change', handleCatalogSearchInput);
        if (dom.supplies.catalogClear) {
          dom.supplies.catalogClear.addEventListener('click', () => {
            dom.supplies.catalogSearch.value = '';
            state.catalog.search = '';
            selectCatalogSku('', { updateSearch: false, preserveDescription: true });
            renderCatalog();
            updateCatalogSearchAffordances();
            dom.supplies.catalogSearch.focus();
          });
        }
        if (dom.supplies.catalogScroll) {
          dom.supplies.catalogScroll.addEventListener('click', () => {
            state.catalog.search = '';
            if (dom.supplies.catalogSearch) {
              dom.supplies.catalogSearch.value = '';
            }
            selectCatalogSku('', { updateSearch: false, preserveDescription: true });
            ensureFullCatalogLoaded();
            renderCatalog();
            if (dom.supplies.catalogCard) {
              window.requestAnimationFrame(() => {
                dom.supplies.catalogCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
              });
            }
          });
        }
        if (dom.supplies.plantCheck) {
          dom.supplies.plantCheck.addEventListener('change', () => {
            setFormState('supplies', { plantConfirmed: dom.supplies.plantCheck.checked });
            persistForm('supplies');
          });
        }
        dom.supplies.more.addEventListener('click', () => {
          if (!state.loading.supplies && state.nextTokens.supplies) {
            loadRequests('supplies', { append: true });
          }
        });
        dom.supplies.catalogMore.addEventListener('click', () => {
          if (!state.catalog.loading) {
            loadCatalog({ append: false, fetchAll: true });
          }
        });
        dom.it.form.addEventListener('submit', evt => handleSubmit(evt, 'it'));
        dom.it.reset.addEventListener('click', () => {
          resetForm('it');
        });
        dom.it.location.addEventListener('change', () => {
          setFormState('it', { location: dom.it.location.value });
          persistForm('it');
        });
        if (dom.it.requesterName) {
          dom.it.requesterName.addEventListener('input', () => {
            handleRequesterNameInput('it');
          });
        }
        dom.it.issue.addEventListener('input', () => {
          setFormState('it', { issue: dom.it.issue.value });
          persistForm('it');
        });
        dom.it.device.addEventListener('input', () => {
          setFormState('it', { device: dom.it.device.value });
          persistForm('it');
        });
        dom.it.urgency.addEventListener('change', () => {
          setFormState('it', { urgency: dom.it.urgency.value });
          persistForm('it');
        });
        dom.it.details.addEventListener('input', () => {
          setFormState('it', { details: dom.it.details.value });
          persistForm('it');
        });
        dom.it.more.addEventListener('click', () => {
          if (!state.loading.it && state.nextTokens.it) {
            loadRequests('it', { append: true });
          }
        });

        dom.maintenance.form.addEventListener('submit', evt => handleSubmit(evt, 'maintenance'));
        dom.maintenance.reset.addEventListener('click', () => {
          resetForm('maintenance');
        });
        dom.maintenance.location.addEventListener('change', () => {
          setFormState('maintenance', { location: dom.maintenance.location.value });
          persistForm('maintenance');
        });
        if (dom.maintenance.requesterName) {
          dom.maintenance.requesterName.addEventListener('input', () => {
            handleRequesterNameInput('maintenance');
          });
        }
        dom.maintenance.issue.addEventListener('input', () => {
          setFormState('maintenance', { issue: dom.maintenance.issue.value });
          persistForm('maintenance');
        });
        dom.maintenance.urgency.addEventListener('change', () => {
          setFormState('maintenance', { urgency: dom.maintenance.urgency.value });
          persistForm('maintenance');
        });
        dom.maintenance.accessNotes.addEventListener('input', () => {
          setFormState('maintenance', { accessNotes: dom.maintenance.accessNotes.value });
          persistForm('maintenance');
        });
        dom.maintenance.more.addEventListener('click', () => {
          if (!state.loading.maintenance && state.nextTokens.maintenance) {
            loadRequests('maintenance', { append: true });
          }
        });
      }

      function attachFeedbackHandlers() {
        const feedback = dom.feedback;
        if (!feedback || !feedback.launcher || !feedback.dialog || !feedback.form) {
          return;
        }
        if (feedback.submit && !feedback.submit.dataset.defaultLabel) {
          feedback.submit.dataset.defaultLabel = feedback.submit.textContent || 'Send';
        }
        feedback.launcher.addEventListener('click', () => {
          if (feedbackState.submitting) {
            return;
          }
          openFeedbackDialog();
        });
        if (feedback.close) {
          feedback.close.addEventListener('click', () => {
            closeFeedbackDialog({ restoreFocus: true });
          });
        }
        if (feedback.cancel) {
          feedback.cancel.addEventListener('click', () => {
            closeFeedbackDialog({ restoreFocus: true });
          });
        }
        feedback.dialog.addEventListener('click', evt => {
          if (feedbackState.submitting) {
            return;
          }
          if (evt.target === feedback.dialog) {
            closeFeedbackDialog({ restoreFocus: true });
          }
        });
        feedback.form.addEventListener('submit', handleFeedbackSubmit);
        const typeInputs = feedback.typeInputs || [];
        typeInputs.forEach(input => {
          const chip = input.closest('.feedback-chip');
          updateFeedbackChipState(chip, Boolean(input.checked));
          input.addEventListener('change', () => {
            typeInputs.forEach(other => {
              const otherChip = other.closest('.feedback-chip');
              updateFeedbackChipState(otherChip, Boolean(other.checked));
            });
          });
          input.addEventListener('focus', () => {
            const owner = input.closest('.feedback-chip');
            if (owner) {
              owner.dataset.focused = 'true';
            }
          });
          input.addEventListener('blur', () => {
            const owner = input.closest('.feedback-chip');
            if (owner) {
              delete owner.dataset.focused;
            }
          });
        });
        document.addEventListener('keydown', handleFeedbackKeydown);
      }

      function attachInsightHandlers() {
        const insights = dom.dashboard && dom.dashboard.insights;
        if (!insights) {
          return;
        }
        const buttons = insights.viewButtons || [];
        buttons.forEach(button => {
          if (!button) {
            return;
          }
          const label = button.textContent ? button.textContent.trim() : '';
          if (!button.dataset.defaultLabel) {
            button.dataset.defaultLabel = label || 'View details';
          }
          button.addEventListener('click', () => {
            const targetType = button.getAttribute('data-insights-view');
            openInsightsModal(typeof targetType === 'string' ? targetType : '', button);
          });
        });

        const modal = insights.modal || {};
        if (modal.close) {
          modal.close.addEventListener('click', () => {
            closeInsightsModal({ restoreFocus: true });
          });
        }
        if (modal.container) {
          modal.container.addEventListener('click', evt => {
            if (evt.target === modal.container) {
              closeInsightsModal({ restoreFocus: true });
            }
          });
        }
        document.addEventListener('keydown', handleInsightsModalKeydown);
      }

      function openInsightsModal(type, trigger) {
        const insights = dom.dashboard && dom.dashboard.insights;
        if (!insights || !insights.modal || !insights.modal.container) {
          return;
        }
        const modal = insights.modal;
        const normalizedType = type === 'technical' ? 'technical' : 'supplies';
        insightModalState.open = true;
        insightModalState.type = normalizedType;
        insightModalState.trigger = trigger && typeof trigger.focus === 'function' ? trigger : null;
        modal.container.hidden = false;
        renderInsightsModal(normalizedType);
        window.requestAnimationFrame(() => {
          if (modal.card && typeof modal.card.focus === 'function') {
            modal.card.focus();
          }
        });
      }

      function closeInsightsModal(options) {
        const insights = dom.dashboard && dom.dashboard.insights;
        if (!insights || !insights.modal || !insights.modal.container) {
          return;
        }
        if (!insightModalState.open) {
          return;
        }
        const modal = insights.modal;
        insightModalState.open = false;
        modal.container.hidden = true;
        if (modal.body) {
          while (modal.body.firstChild) {
            modal.body.removeChild(modal.body.firstChild);
          }
          modal.body.hidden = false;
        }
        if (modal.empty) {
          modal.empty.hidden = true;
        }
        const shouldRestoreFocus = options && options.restoreFocus;
        if (shouldRestoreFocus && insightModalState.trigger) {
          insightModalState.trigger.focus();
        }
        insightModalState.trigger = null;
      }

      function handleInsightsModalKeydown(evt) {
        if (!insightModalState.open || evt.defaultPrevented) {
          return;
        }
        if (evt.key === 'Escape') {
          evt.preventDefault();
          closeInsightsModal({ restoreFocus: true });
        }
      }

      function renderInsightsModal(type) {
        const insights = dom.dashboard && dom.dashboard.insights;
        if (!insights || !insights.modal) {
          return;
        }
        const modal = insights.modal;
        const body = modal.body;
        const empty = modal.empty;
        if (!body || !empty) {
          return;
        }
        while (body.firstChild) {
          body.removeChild(body.firstChild);
        }
        const normalizedType = type === 'technical' ? 'technical' : 'supplies';
        const insightState = state.dashboard.insights || {
          supplies: [],
          suppliesFull: [],
          itMaintenance: [],
          itMaintenanceFull: []
        };
        const entries = normalizedType === 'technical'
          ? (Array.isArray(insightState.itMaintenanceFull) && insightState.itMaintenanceFull.length
            ? insightState.itMaintenanceFull
            : Array.isArray(insightState.itMaintenance)
              ? insightState.itMaintenance
              : [])
          : (Array.isArray(insightState.suppliesFull) && insightState.suppliesFull.length
            ? insightState.suppliesFull
            : Array.isArray(insightState.supplies)
              ? insightState.supplies
              : []);
        const hasEntries = Array.isArray(entries) && entries.length > 0;
        if (modal.title) {
          modal.title.textContent = normalizedType === 'technical'
            ? 'IT & Maintenance insights'
            : 'Supplies insights';
        }
        if (modal.description) {
          modal.description.textContent = normalizedType === 'technical'
            ? 'See the locations logging the most IT and Maintenance requests.'
            : 'See the catalog items most requested across locations.';
        }
        if (!hasEntries) {
          body.hidden = true;
          empty.hidden = false;
          empty.textContent = !hasServer
            ? 'Connect to Google Apps Script to load live data.'
            : normalizedType === 'technical'
              ? 'No IT or Maintenance requests yet.'
              : 'No supplies requests yet.';
          return;
        }
        body.hidden = false;
        empty.hidden = true;
        const table = buildInsightsModalTable(normalizedType, entries);
        if (table) {
          body.appendChild(table);
        }
      }

      function buildInsightsModalTable(type, entries) {
        const table = document.createElement('table');
        table.className = 'insights-modal-table';
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        const headers = type === 'technical'
          ? ['Location', 'Total requests', 'IT', 'Maintenance']
          : ['Location', 'Catalog item', 'Quantity requested', 'Requests submitted'];
        headers.forEach(label => {
          const th = document.createElement('th');
          th.scope = 'col';
          th.textContent = label;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        entries.forEach(entry => {
          const row = type === 'technical'
            ? buildTechnicalModalRow(entry)
            : buildSuppliesModalRow(entry);
          if (row) {
            tbody.appendChild(row);
          }
        });
        table.appendChild(tbody);
        return table;
      }

      function buildSuppliesModalRow(entry) {
        if (!entry) {
          return null;
        }
        const row = document.createElement('tr');
        const locationCell = document.createElement('td');
        locationCell.textContent = typeof entry.location === 'string' && entry.location.trim()
          ? entry.location.trim()
          : 'Unknown';
        const itemCell = document.createElement('td');
        const itemName = document.createElement('strong');
        itemName.textContent = typeof entry.item === 'string' && entry.item.trim() ? entry.item.trim() : '—';
        itemCell.appendChild(itemName);
        const sku = typeof entry.catalogSku === 'string' && entry.catalogSku.trim() ? entry.catalogSku.trim() : '';
        if (sku) {
          const skuLine = document.createElement('span');
          skuLine.className = 'insights-modal-meta';
          skuLine.textContent = `SKU ${sku}`;
          itemCell.appendChild(skuLine);
        }
        const quantityCell = document.createElement('td');
        const quantityValue = Number(entry.quantity);
        quantityCell.textContent = Number.isFinite(quantityValue) && quantityValue > 0
          ? formatDashboardCount(quantityValue)
          : '0';
        const requestsCell = document.createElement('td');
        const requestValue = Number(entry.requestCount);
        requestsCell.textContent = Number.isFinite(requestValue) && requestValue > 0
          ? formatDashboardCount(requestValue)
          : '0';
        row.appendChild(locationCell);
        row.appendChild(itemCell);
        row.appendChild(quantityCell);
        row.appendChild(requestsCell);
        return row;
      }

      function buildTechnicalModalRow(entry) {
        if (!entry) {
          return null;
        }
        const row = document.createElement('tr');
        const locationCell = document.createElement('td');
        locationCell.textContent = typeof entry.location === 'string' && entry.location.trim()
          ? entry.location.trim()
          : 'Unknown';
        const totalCell = document.createElement('td');
        const totalValue = Number(entry.count);
        const totalLabel = Number.isFinite(totalValue) && totalValue > 0
          ? formatDashboardCount(totalValue)
          : '0';
        const totalStrong = document.createElement('strong');
        totalStrong.textContent = totalLabel;
        totalCell.appendChild(totalStrong);
        const itCell = document.createElement('td');
        const itValue = Number(entry.itCount);
        itCell.textContent = Number.isFinite(itValue) && itValue > 0
          ? formatDashboardCount(itValue)
          : '0';
        const maintenanceCell = document.createElement('td');
        const maintenanceValue = Number(entry.maintenanceCount);
        maintenanceCell.textContent = Number.isFinite(maintenanceValue) && maintenanceValue > 0
          ? formatDashboardCount(maintenanceValue)
          : '0';
        row.appendChild(locationCell);
        row.appendChild(totalCell);
        row.appendChild(itCell);
        row.appendChild(maintenanceCell);
        return row;
      }

      function openFeedbackDialog() {
        const feedback = dom.feedback;
        if (!feedback || !feedback.dialog) {
          return;
        }
        if (feedbackState.closeTimer) {
          window.clearTimeout(feedbackState.closeTimer);
          feedbackState.closeTimer = null;
        }
        feedbackState.open = true;
        feedback.dialog.hidden = false;
        if (feedback.launcher) {
          feedback.launcher.setAttribute('aria-expanded', 'true');
        }
        clearFeedbackStatus();
        window.requestAnimationFrame(() => {
          if (feedback.details) {
            feedback.details.focus();
          } else if (feedback.summary) {
            feedback.summary.focus();
          }
        });
      }

      function closeFeedbackDialog(options) {
        const feedback = dom.feedback;
        if (!feedback || !feedback.dialog) {
          return;
        }
        if (feedbackState.closeTimer) {
          window.clearTimeout(feedbackState.closeTimer);
          feedbackState.closeTimer = null;
        }
        feedbackState.open = false;
        feedback.dialog.hidden = true;
        if (feedback.launcher) {
          feedback.launcher.setAttribute('aria-expanded', 'false');
        }
        if (options && options.restoreFocus && feedback.launcher) {
          feedback.launcher.focus();
        }
        if (options && options.reset) {
          resetFeedbackForm();
        }
        clearFeedbackStatus();
      }

      function handleFeedbackKeydown(evt) {
        if (!feedbackState.open || feedbackState.submitting || evt.defaultPrevented) {
          return;
        }
        if (evt.key === 'Escape') {
          evt.preventDefault();
          closeFeedbackDialog({ restoreFocus: true });
        }
      }

      function handleFeedbackSubmit(evt) {
        evt.preventDefault();
        const feedback = dom.feedback;
        if (!feedback || !feedback.form || feedbackState.submitting) {
          return;
        }
        if (!feedback.form.checkValidity()) {
          feedback.form.reportValidity();
          return;
        }
        clearFeedbackStatus();
        setFeedbackSubmitting(true);
        const selectedType = getSelectedFeedbackType();
        const payload = {
          cid: makeCid(),
          clientRequestId: makeClientRequestId('feedback'),
          feedback: {
            type: selectedType,
            summary: sanitizeFeedbackText(feedback.summary && feedback.summary.value),
            details: sanitizeFeedbackText(feedback.details && feedback.details.value),
            contact: sanitizeFeedbackText(feedback.contact && feedback.contact.value)
          }
        };
        const onSuccess = () => {
          setFeedbackSubmitting(false);
          setFeedbackStatus('Love it! We\'ll make sure the team sees this insight.', 'success');
          resetFeedbackForm({ preserveStatus: true });
          feedbackState.closeTimer = window.setTimeout(() => {
            closeFeedbackDialog({ restoreFocus: true, reset: true });
          }, 2400);
          showToast('Thanks! Your idea is on its way ✉️');
        };
        const onError = err => {
          setFeedbackSubmitting(false);
          const message = resolveErrorMessage(err);
          setFeedbackStatus(message, 'error');
        };
        if (!server) {
          window.setTimeout(onSuccess, 300);
          return;
        }
        server
          .withSuccessHandler(response => {
            if (!response || !response.ok) {
              onError(response);
              return;
            }
            onSuccess();
          })
          .withFailureHandler(onError)
          .submitAppFeedback(payload);
      }

      function setFeedbackSubmitting(submitting) {
        const feedback = dom.feedback;
        feedbackState.submitting = Boolean(submitting);
        if (!feedback) {
          return;
        }
        const typeInputs = feedback.typeInputs || [];
        typeInputs.forEach(input => {
          input.disabled = feedbackState.submitting;
        });
        ['summary', 'details', 'contact'].forEach(key => {
          const field = feedback[key];
          if (field) {
            field.disabled = feedbackState.submitting;
          }
        });
        if (feedback.submit) {
          const defaultLabel = feedback.submit.dataset.defaultLabel || 'Send';
          feedback.submit.disabled = feedbackState.submitting;
          feedback.submit.textContent = feedbackState.submitting ? 'Sending…' : defaultLabel;
        }
        if (feedback.cancel) {
          feedback.cancel.disabled = feedbackState.submitting;
        }
        if (feedback.close) {
          feedback.close.disabled = feedbackState.submitting;
        }
      }

      function setFeedbackStatus(message, state) {
        const feedback = dom.feedback;
        if (!feedback || !feedback.status) {
          return;
        }
        if (!message) {
          clearFeedbackStatus();
          return;
        }
        feedback.status.hidden = false;
        feedback.status.dataset.state = state === 'error' ? 'error' : 'success';
        feedback.status.textContent = message;
      }

      function clearFeedbackStatus() {
        const feedback = dom.feedback;
        if (!feedback || !feedback.status) {
          return;
        }
        feedback.status.hidden = true;
        feedback.status.textContent = '';
        delete feedback.status.dataset.state;
      }

      function resetFeedbackForm(options) {
        const feedback = dom.feedback;
        if (!feedback || !feedback.form) {
          return;
        }
        feedback.form.reset();
        const typeInputs = feedback.typeInputs || [];
        typeInputs.forEach(input => {
          const chip = input.closest('.feedback-chip');
          updateFeedbackChipState(chip, Boolean(input.checked));
        });
        if (!options || !options.preserveStatus) {
          clearFeedbackStatus();
        }
      }

      function updateFeedbackChipState(chip, selected) {
        if (!chip) {
          return;
        }
        chip.dataset.selected = selected ? 'true' : 'false';
      }

      function getSelectedFeedbackType() {
        const feedback = dom.feedback;
        if (!feedback) {
          return '';
        }
        const match = (feedback.typeInputs || []).find(input => input.checked);
        return match ? sanitizeFeedbackText(match.value) : '';
      }

      function sanitizeFeedbackText(value) {
        return typeof value === 'string' ? value.trim() : '';
      }

      function setActiveTab(type) {
        state.activeTab = type;
        if (document && document.body) {
          document.body.dataset.activeTab = type;
        }
        dom.tabButtons.forEach(button => {
          button.classList.toggle('active', button.getAttribute('data-tab-trigger') === type);
        });
        dom.panels.forEach(panel => {
          panel.classList.toggle('active', panel.getAttribute('data-tab-panel') === type);
        });
        ensureRequestsLoaded(type);
        scheduleWarmCache();
      }

      function ensureRequestsLoaded(type) {
        if (state.loaded[type] || !hasServer) {
          return;
        }
        loadRequests(type, { append: false });
      }

      function scheduleWarmCache() {
        if (!hasServer || warmScheduled) {
          return;
        }
        warmScheduled = true;
        const idle = typeof window.requestIdleCallback === 'function'
          ? window.requestIdleCallback
          : callback => setTimeout(() => callback({ didTimeout: false }), 600);
        idle(() => {
          const others = REQUEST_KEYS.filter(tab => tab !== state.activeTab);
          others.forEach((type, index) => {
            setTimeout(() => {
              if (!state.loaded[type]) {
                loadRequests(type, { append: false });
              }
            }, index * 220);
          });
        });
      }

      function scheduleCatalogWarm() {
        if (!hasServer || state.catalog.fullyLoaded || catalogWarmScheduled || catalogWarmInFlight) {
          return;
        }
        catalogWarmScheduled = true;
        const idle = typeof window.requestIdleCallback === 'function'
          ? window.requestIdleCallback
          : callback => setTimeout(() => callback({ didTimeout: false }), 900);
        idle(() => {
          catalogWarmScheduled = false;
          if (!hasServer || state.catalog.fullyLoaded || catalogWarmInFlight) {
            return;
          }
          catalogWarmInFlight = true;
          loadCatalog({
            append: false,
            fetchAll: true,
            background: true,
            onComplete: () => {
              catalogWarmInFlight = false;
            }
          });
        });
      }

      function handleSubmit(event, type) {
        event.preventDefault();
        const formState = state.forms[type];
        const validationError = validateForm(type, formState);
        if (validationError) {
          handleError({ message: validationError }, `${type}:validation`);
          return;
        }
        const deviceId = ensureDeviceId();
        if (!deviceId) {
          handleError({ message: 'Unable to identify this device. Please enable local storage and try again.' }, `${type}:device`);
          return;
        }
        if (!server) {
          showToast('Connect to Google Apps Script to submit requests.');
          return;
        }
        disableForm(type, true);
        const payload = Object.assign({
          cid: makeCid(),
          clientRequestId: makeClientRequestId(type),
          type,
          deviceId
        }, formState);
        if (requiresRequesterName) {
          payload.requesterName = state.requesterName || formState.requesterName || '';
        }
        server
          .withSuccessHandler(response => {
            disableForm(type, false);
            if (!response || !response.ok || !response.request) {
              handleError(response, 'createRequest', payload);
              return;
            }
            showToast('Request submitted');
            setRequesterName('', { skipPersist: true });
            REQUEST_KEYS.forEach(key => {
              resetForm(key, { preserveRequesterName: false });
            });
            state.requests[type].unshift(response.request);
            renderRequests(type);
            requestDashboardRefresh(DASHBOARD_DEBOUNCE);
          })
          .withFailureHandler(err => {
            disableForm(type, false);
            handleError(err, 'createRequest', payload);
          })
          .createRequest(payload);
      }

      function validateForm(type, formState) {
        if (requiresRequesterName) {
          const nameValue = (state.requesterName || formState.requesterName || '').trim();
          if (!nameValue) {
            return 'Your name is required.';
          }
        }
        switch (type) {
          case 'supplies':
            if (!formState.location || !formState.location.trim()) {
              return 'Location is required.';
            }
            if (!formState.description || !formState.description.trim()) {
              return 'Item name is required.';
            }
            if (!formState.qty || Number(formState.qty) <= 0) {
              return 'Quantity must be at least 1.';
            }
            if (!formState.plantConfirmed) {
              return 'Please confirm you have checked with The Plant & our supplies cabinet first.';
            }
            return '';
          case 'it':
            if (!formState.location || !formState.location.trim()) {
              return 'Location is required.';
            }
            if (!formState.issue || !formState.issue.trim()) {
              return 'Issue summary is required.';
            }
            return '';
          case 'maintenance':
            if (!formState.location || !formState.location.trim()) {
              return 'Location is required.';
            }
            if (!formState.issue || !formState.issue.trim()) {
              return 'Issue description is required.';
            }
            return '';
          default:
            return 'Unsupported request type.';
        }
      }

      function resetForm(type, options) {
        const opts = options || {};
        const preserveRequester = opts.preserveRequesterName !== false;
        state.forms[type] = Object.assign({}, FORM_TEMPLATES[type]);
        if (requiresRequesterName) {
          state.forms[type].requesterName = preserveRequester ? (state.requesterName || '') : '';
        }
        if (type === 'supplies') {
          state.catalog.search = '';
          if (dom.supplies.catalogSearch) {
            dom.supplies.catalogSearch.value = '';
          }
        }
        renderForm(type);
        if (type === 'supplies' && state.catalog.items.length) {
          renderCatalog();
        }
        if (opts.skipPersistenceClear) {
          if (opts.persistImmediately) {
            persistForm(type, { immediate: true });
          }
        } else {
          clearPersistedForm(type);
        }
      }

      function renderForm(type) {
        const formState = state.forms[type];
        if (type === 'supplies') {
          dom.supplies.catalogSku.value = formState.catalogSku || '';
          dom.supplies.location.value = formState.location || '';
          dom.supplies.qty.value = formState.qty || 1;
          dom.supplies.description.value = formState.description || '';
          dom.supplies.notes.value = formState.notes || '';
          if (dom.supplies.plantCheck) {
            dom.supplies.plantCheck.checked = Boolean(formState.plantConfirmed);
          }
          if (dom.supplies.requesterName) {
            dom.supplies.requesterName.value = requiresRequesterName
              ? (formState.requesterName || state.requesterName || '')
              : '';
          }
        } else if (type === 'it') {
          dom.it.location.value = formState.location || '';
          dom.it.issue.value = formState.issue || '';
          dom.it.device.value = formState.device || '';
          const itUrgency = normalizeUrgency(formState.urgency) || 'normal';
          dom.it.urgency.value = itUrgency;
          state.forms.it.urgency = itUrgency;
          dom.it.details.value = formState.details || '';
          if (dom.it.requesterName) {
            dom.it.requesterName.value = requiresRequesterName
              ? (formState.requesterName || state.requesterName || '')
              : '';
          }
        } else if (type === 'maintenance') {
          dom.maintenance.location.value = formState.location || '';
          dom.maintenance.issue.value = formState.issue || '';
          const maintenanceUrgency = normalizeUrgency(formState.urgency) || 'normal';
          dom.maintenance.urgency.value = maintenanceUrgency;
          state.forms.maintenance.urgency = maintenanceUrgency;
          dom.maintenance.accessNotes.value = formState.accessNotes || '';
          if (dom.maintenance.requesterName) {
            dom.maintenance.requesterName.value = requiresRequesterName
              ? (formState.requesterName || state.requesterName || '')
              : '';
          }
        }
      }

      function loadRequests(type, { append }) {
        if (state.loading[type]) {
          return;
        }
        if (!server) {
          state.loaded[type] = true;
          renderRequests(type);
          if (type === 'supplies') {
            resolveInitialTask('requests:supplies');
          }
          return;
        }
        state.loading[type] = true;
        const moreButton = dom[type].more;
        if (moreButton) {
          moreButton.disabled = true;
        }
        toggleRequestsSkeleton(type, true);
        const payload = {
          cid: makeCid(),
          type,
          pageSize: 10,
          scope: 'all',
          nextToken: append ? state.nextTokens[type] : ''
        };
        server
          .withSuccessHandler(response => {
            state.loading[type] = false;
            state.loaded[type] = true;
            toggleRequestsSkeleton(type, false);
            if (!response || !response.ok) {
              handleError(response, 'listRequests', payload);
              return;
            }
            state.nextTokens[type] = response.nextToken || '';
            const items = Array.isArray(response.requests) ? response.requests : [];
            state.requests[type] = append ? state.requests[type].concat(items) : items;
            renderRequests(type);
            if (type === 'supplies') {
              resolveInitialTask('requests:supplies');
            }
          })
          .withFailureHandler(err => {
            state.loading[type] = false;
            state.loaded[type] = true;
            toggleRequestsSkeleton(type, false);
            handleError(err, 'listRequests', payload);
            if (type === 'supplies') {
              resolveInitialTask('requests:supplies');
            }
          })
          .listRequests(payload);
      }

      function renderRequests(type) {
        const list = dom[type].list;
        const moreButton = dom[type].more;
        list.textContent = '';
        if (!state.requests[type].length) {
          if (state.loading[type]) {
            list.appendChild(buildSkeletonBlock());
          } else {
            const empty = document.createElement('p');
            empty.className = 'empty';
            const message = EMPTY_REQUEST_MESSAGES[type];
            empty.textContent = hasServer ? message : 'Connect to Google Apps Script to load requests.';
            list.appendChild(empty);
          }
          if (moreButton) {
            moreButton.disabled = true;
          }
          return;
        }
        const fragment = document.createDocumentFragment();
        const sortedEntries = state.requests[type]
          .map((request, index) => ({ request, index }))
          .sort((left, right) => compareRequestsForDisplay(type, left, right));
        sortedEntries.forEach(entry => {
          const request = entry.request;
          const item = document.createElement('article');
          item.className = 'request-item';
          item.dataset.requestType = type;
          item.dataset.requestId = request.id;

          const head = document.createElement('div');
          head.className = 'request-item-head';

          const title = document.createElement('strong');
          title.className = 'request-item-title';
          title.textContent = request.summary || 'Request';
          head.appendChild(title);

          if ((type === 'it' || type === 'maintenance') && request.fields) {
            const urgencyKey = normalizeUrgency(request.fields.urgency);
            if (urgencyKey) {
              const urgencyBadge = document.createElement('span');
              urgencyBadge.className = 'urgency-badge request-urgency';
              urgencyBadge.dataset.urgency = urgencyKey;
              urgencyBadge.textContent = formatUrgencyLabel(urgencyKey);
              head.appendChild(urgencyBadge);
            }
          }

          const status = document.createElement('span');
          status.className = 'status';
          const stateKey = getRequestStateKey(request.status);
          const isClosed = isRequestClosed(stateKey);
          const isActive = isRequestActive(type, stateKey);
          item.dataset.requestState = stateKey;
          item.dataset.requestActive = isActive ? 'true' : 'false';
          status.dataset.state = stateKey;
          status.textContent = formatStatus(stateKey);
          head.appendChild(status);
          item.appendChild(head);

          const info = document.createElement('div');
          info.className = 'request-item-info';

          const meta = document.createElement('span');
          meta.className = 'meta';
          meta.textContent = buildRequestMeta(request, type);
          info.appendChild(meta);

          if (Array.isArray(request.details)) {
            request.details.forEach(detail => {
              if (!detail) return;
              const line = document.createElement('span');
              line.className = 'detail-line';
              line.textContent = detail;
              info.appendChild(line);
            });
          }

          const submittedLine = document.createElement('span');
          submittedLine.className = 'detail-line';
          const requesterLabel = formatActorName(request.requester) || 'Unknown requester';
          submittedLine.textContent = `Submitted by: ${requesterLabel}`;
          info.appendChild(submittedLine);

          const statusLineText = buildStatusActorLine(type, stateKey, request.approver);
          if (statusLineText) {
            const statusLine = document.createElement('span');
            statusLine.className = 'detail-line';
            statusLine.textContent = statusLineText;
            info.appendChild(statusLine);
          }

          item.appendChild(info);

          if (supportsNotes(type)) {
            const notesSection = buildRequestNotesSection(request, type);
            if (notesSection) {
              item.appendChild(notesSection);
            }
          }

          const footer = document.createElement('div');
          footer.className = 'request-item-footer';

          const showEtaField = type === 'supplies' && shouldShowEtaField(stateKey);

          if (showEtaField) {
            const etaWrapper = document.createElement('label');
            etaWrapper.className = 'eta-field';

            const etaText = document.createElement('span');
            etaText.textContent = 'ETA';
            etaWrapper.appendChild(etaText);

            const etaInput = document.createElement('input');
            etaInput.type = 'date';
            etaInput.autocomplete = 'off';
            const previousEta = getRequestEta(request);
            etaInput.value = previousEta;
            etaInput.setAttribute('aria-label', `ETA for ${request.summary || 'request'}`);
            const etaStatusAllowed = canEditEtaStatus(stateKey);
            const etaEditable = server && canManageStatuses && etaStatusAllowed;
            if (!etaEditable) {
              etaInput.disabled = true;
            }
            if (!canManageStatuses) {
              etaInput.title = 'Only authorized approvers can update ETA.';
            } else if (!etaStatusAllowed) {
              etaInput.title = 'ETA can be set after approval only.';
            } else {
              etaInput.title = '';
            }
            if (etaEditable) {
              etaInput.addEventListener('change', () => {
                const nextValue = etaInput.value;
                if (nextValue === previousEta) {
                  return;
                }
                handleUpdateEta(type, request, nextValue, etaInput, previousEta);
              });
            }
            etaWrapper.appendChild(etaInput);
            footer.appendChild(etaWrapper);
          }

          if (type === 'supplies' && canManageStatuses) {
            const buttonRow = document.createElement('div');
            buttonRow.className = 'inline-buttons';
            let hasButtons = false;

            if (stateKey === 'pending') {
              const approved = document.createElement('button');
              approved.type = 'button';
              approved.className = 'secondary';
              approved.textContent = 'Approved';
              approved.addEventListener('click', () => handleUpdateStatus(type, request.id, 'approved'));
              buttonRow.appendChild(approved);

              const denied = document.createElement('button');
              denied.type = 'button';
              denied.className = 'secondary';
              denied.textContent = 'Denied';
              denied.addEventListener('click', () => handleUpdateStatus(type, request.id, 'denied'));
              buttonRow.appendChild(denied);
              hasButtons = true;
            }

            if (hasButtons) {
              const controls = document.createElement('div');
              controls.className = 'supplies-actions';
              controls.appendChild(buttonRow);
              footer.appendChild(controls);
            }
          } else if (canManageStatuses && (stateKey === 'pending' || stateKey === 'in_progress')) {
            const actions = document.createElement('div');
            actions.className = 'inline-buttons';
            const complete = document.createElement('button');
            complete.type = 'button';
            complete.className = 'secondary';
            complete.textContent = 'Complete';
            complete.addEventListener('click', () => handleUpdateStatus(type, request.id, 'completed'));
            actions.appendChild(complete);

            const progress = document.createElement('button');
            progress.type = 'button';
            progress.className = 'secondary';
            progress.textContent = 'In Progress';
            progress.addEventListener('click', () => handleUpdateStatus(type, request.id, 'in_progress'));
            progress.classList.toggle('active', stateKey === 'in_progress');
            progress.setAttribute('aria-pressed', stateKey === 'in_progress' ? 'true' : 'false');
            actions.appendChild(progress);

            const denied = document.createElement('button');
            denied.type = 'button';
            denied.className = 'secondary';
            denied.textContent = 'Denied';
            denied.addEventListener('click', () => handleUpdateStatus(type, request.id, 'denied'));
            actions.appendChild(denied);

            footer.appendChild(actions);
          }

          if (footer.childElementCount) {
            item.appendChild(footer);
          }

          fragment.appendChild(item);
        });
        list.appendChild(fragment);
        if (moreButton) {
          moreButton.disabled = !state.nextTokens[type];
        }
      }

      function handleUpdateStatus(type, requestId, status) {
        if (!canManageStatuses) {
          showToast('You are not authorized to update requests.');
          return;
        }
        if (!server) {
          showToast('Connect to Google Apps Script to update statuses.');
          return;
        }
        const payload = {
          cid: makeCid(),
          clientRequestId: makeClientRequestId(type),
          type,
          requestId,
          status
        };
        const item = dom[type].list.querySelector(`article[data-request-id="${requestId}"]`);
        const interactive = item
          ? Array.from(item.querySelectorAll('button'))
          : [];
        interactive.forEach(element => { element.disabled = true; });
        server
          .withSuccessHandler(response => {
            interactive.forEach(element => { element.disabled = false; });
            if (!response || !response.ok || !response.request) {
              handleError(response, 'updateRequestStatus', payload);
              return;
            }
            const updated = response.request;
            const index = state.requests[type].findIndex(entry => entry.id === updated.id);
            if (index >= 0) {
              state.requests[type][index] = updated;
              renderRequests(type);
            }
            showToast('Request updated');
            requestDashboardRefresh(DASHBOARD_DEBOUNCE);
          })
          .withFailureHandler(err => {
            interactive.forEach(element => { element.disabled = false; });
            handleError(err, 'updateRequestStatus', payload);
          })
          .updateRequestStatus(payload);
      }

      function handleAddNote(type, request, textarea, submitButton) {
        if (!canManageStatuses) {
          showToast('You are not authorized to add notes.');
          return;
        }
        const currentValue = textarea.value || '';
        setNoteDraft(type, request.id, currentValue);
        const trimmed = currentValue.trim();
        if (!trimmed) {
          showToast('Add a note before submitting.');
          return;
        }
        if (!server) {
          showToast('Connect to Google Apps Script to add notes.');
          return;
        }
        const payload = {
          cid: makeCid(),
          clientRequestId: makeClientRequestId(type),
          type,
          requestId: request.id,
          note: trimmed
        };
        textarea.disabled = true;
        submitButton.disabled = true;
        server
          .withSuccessHandler(response => {
            textarea.disabled = false;
            submitButton.disabled = false;
            if (!response || !response.ok || !response.request) {
              handleError(response, 'addRequestNote', payload);
              return;
            }
            const updated = response.request;
            const index = state.requests[type].findIndex(entry => entry.id === updated.id);
            if (index >= 0) {
              state.requests[type][index] = updated;
            }
            clearNoteDraft(type, request.id);
            renderRequests(type);
            showToast('Note added');
          })
          .withFailureHandler(err => {
            textarea.disabled = false;
            submitButton.disabled = false;
            handleError(err, 'addRequestNote', payload);
          })
          .addRequestNote(payload);
      }

      function handleUpdateEta(type, request, etaValue, input, previousEta) {
        if (!canManageStatuses) {
          showToast('You are not authorized to update requests.');
          input.value = previousEta;
          return;
        }
        if (!server) {
          showToast('Connect to Google Apps Script to update ETA dates.');
          input.value = previousEta;
          return;
        }
        if (!request || !request.id) {
          input.value = previousEta;
          handleError({ message: 'Request not found.' }, 'updateRequestEta');
          return;
        }
        if (!canEditEtaStatus(request && request.status)) {
          input.value = previousEta;
          showToast('ETA can be set after approval only.');
          return;
        }
        const payload = {
          cid: makeCid(),
          clientRequestId: makeClientRequestId(type),
          type,
          requestId: request.id,
          status: request.status || 'pending',
          eta: etaValue
        };
        input.disabled = true;
        server
          .withSuccessHandler(response => {
            input.disabled = false;
            if (!response || !response.ok || !response.request) {
              input.value = previousEta;
              handleError(response, 'updateRequestEta', payload);
              return;
            }
            const updated = response.request;
            const index = state.requests[type].findIndex(entry => entry.id === updated.id);
            if (index >= 0) {
              state.requests[type][index] = updated;
              renderRequests(type);
            }
            const updatedEta = getRequestEta(updated);
            showToast(updatedEta ? 'ETA updated' : 'ETA cleared');
            requestDashboardRefresh(DASHBOARD_DEBOUNCE);
          })
          .withFailureHandler(err => {
            input.disabled = false;
            input.value = previousEta;
            handleError(err, 'updateRequestEta', payload);
          })
          .updateRequestStatus(payload);
      }

      function shouldShowEtaField(status) {
        const key = typeof status === 'string'
          ? status.trim().toLowerCase().replace(/\s+/g, '_')
          : '';
        return !HIDE_ETA_STATUSES.has(key);
      }

      function getRequestStateKey(status) {
        if (typeof status !== 'string') {
          return '';
        }
        return status.trim().toLowerCase().replace(/\s+/g, '_');
      }

      function isRequestClosed(stateKey) {
        if (!stateKey) {
          return false;
        }
        return CLOSED_REQUEST_STATES.has(stateKey);
      }

      function isRequestActive(type, stateKey) {
        if (!stateKey) {
          return false;
        }
        if (type === 'supplies') {
          return stateKey === 'pending';
        }
        return !isRequestClosed(stateKey);
      }

      function getRequestPriorityRank(type, stateKey) {
        if (type === 'supplies') {
          if (stateKey === 'pending') {
            return 0;
          }
          if (isRequestClosed(stateKey)) {
            return 2;
          }
          return 1;
        }
        return isRequestClosed(stateKey) ? 1 : 0;
      }

      function getRequestUrgencyRank(type, request) {
        if (type !== 'it' && type !== 'maintenance') {
          return URGENCY_SORT_ORDER.normal;
        }
        const fields = request && request.fields ? request.fields : {};
        const urgencyKey = normalizeUrgency(fields.urgency) || 'normal';
        return Object.prototype.hasOwnProperty.call(URGENCY_SORT_ORDER, urgencyKey)
          ? URGENCY_SORT_ORDER[urgencyKey]
          : URGENCY_SORT_ORDER.normal;
      }

      function compareRequestsForDisplay(type, left, right) {
        const leftState = getRequestStateKey(left.request && left.request.status);
        const rightState = getRequestStateKey(right.request && right.request.status);
        const leftPriority = getRequestPriorityRank(type, leftState);
        const rightPriority = getRequestPriorityRank(type, rightState);
        if (leftPriority !== rightPriority) {
          return leftPriority - rightPriority;
        }
        if (type === 'it' || type === 'maintenance') {
          const leftUrgency = getRequestUrgencyRank(type, left.request);
          const rightUrgency = getRequestUrgencyRank(type, right.request);
          if (leftUrgency !== rightUrgency) {
            return leftUrgency - rightUrgency;
          }
        }
        return left.index - right.index;
      }

      function canEditEtaStatus(status) {
        const key = typeof status === 'string'
          ? status.trim().toLowerCase().replace(/\s+/g, '_')
          : '';
        return key === 'approved' || key === 'ordered' || key === 'completed';
      }

      function buildRequestMeta(request, type) {
        const parts = [];
        if (request.ts) {
          try {
            parts.push(new Date(request.ts).toLocaleString());
          } catch (err) {
            parts.push(request.ts);
          }
        }
        const scopeType = typeof type === 'string' ? type : '';
        if (scopeType !== 'supplies') {
          const requesterLabel = formatActorName(request.requester);
          if (requesterLabel) {
            parts.push(requesterLabel);
          }
        }
        return parts.join(' • ');
      }

      function normalizeUrgency(value) {
        const text = typeof value === 'string' ? value.trim().toLowerCase() : '';
        if (!text) {
          return '';
        }
        if (text === 'high') {
          return 'critical';
        }
        if (text === 'medium') {
          return 'normal';
        }
        return text === 'low' || text === 'normal' || text === 'critical' ? text : '';
      }

      function formatUrgencyLabel(value) {
        switch (value) {
          case 'low':
            return 'Low';
          case 'critical':
            return 'Critical';
          case 'normal':
          default:
            return 'Normal';
        }
      }

      function getRequestEta(request) {
        if (!request || !request.fields) {
          return '';
        }
        return String(request.fields.eta || '');
      }

      function loadCatalog({ append, fetchAll, background, onComplete }) {
        const isBackground = Boolean(background);
        if (!server) {
          state.catalog.loading = false;
          state.catalog.backgroundLoading = false;
          toggleCatalogSkeleton(false);
          renderCatalog();
          updateCatalogControls();
          resolveInitialTask('catalog');
          if (typeof onComplete === 'function') {
            onComplete();
          }
          return;
        }
        if (state.catalog.loading) {
          if (typeof onComplete === 'function') {
            onComplete();
          }
          return;
        }
        state.catalog.loading = true;
        state.catalog.backgroundLoading = isBackground;
        if (fetchAll) {
          state.catalog.fullyLoaded = false;
        }
        if (!isBackground) {
          toggleCatalogSkeleton(true);
        }
        updateCatalogControls();
        const payload = {
          cid: makeCid()
        };
        if (fetchAll) {
          payload.fetchAll = true;
        } else {
          payload.pageSize = 20;
          payload.nextToken = append ? state.catalog.nextToken : '';
        }
        server
          .withSuccessHandler(response => {
            state.catalog.loading = false;
            state.catalog.backgroundLoading = false;
            toggleCatalogSkeleton(false);
            if (!response || !response.ok) {
              handleError(response, 'listCatalog', payload);
              updateCatalogControls();
              resolveInitialTask('catalog');
              if (typeof onComplete === 'function') {
                onComplete();
              }
              return;
            }
            state.catalog.nextToken = response.nextToken || '';
            const items = Array.isArray(response.items) ? response.items : [];
            const normalizedItems = enrichCatalogItems(items);
            const currentItems = append && !fetchAll ? state.catalog.items : [];
            state.catalog.items = mergeCatalogItems(currentItems, normalizedItems);
            state.catalog.fullyLoaded = fetchAll || !state.catalog.nextToken;
            updateCatalogIndexes();
            renderCatalog();
            updateCatalogControls();
            resolveInitialTask('catalog');
            if (!isBackground && !state.catalog.fullyLoaded) {
              scheduleCatalogWarm();
            }
            if (typeof onComplete === 'function') {
              onComplete();
            }
          })
          .withFailureHandler(err => {
            state.catalog.loading = false;
            state.catalog.backgroundLoading = false;
            toggleCatalogSkeleton(false);
            handleError(err, 'listCatalog', payload);
            updateCatalogControls();
            resolveInitialTask('catalog');
            if (typeof onComplete === 'function') {
              onComplete();
            }
          })
          .listCatalog(payload);
      }

      function makeCatalogSkuKey(value) {
        if (typeof value === 'string') {
          return value.trim();
        }
        if (typeof value === 'number' && Number.isFinite(value)) {
          return String(value);
        }
        if (value === undefined || value === null) {
          return '';
        }
        const text = String(value);
        return text === 'undefined' || text === 'null' ? '' : text;
      }

      function enrichCatalogItems(items) {
        if (!Array.isArray(items) || !items.length) {
          return [];
        }
        return items.map(raw => {
          const description = typeof raw.description === 'string' ? raw.description.trim() : '';
          const category = typeof raw.category === 'string' ? raw.category.trim() : '';
          const supplier = typeof raw.supplier === 'string' ? raw.supplier.trim() : '';
          const sku = makeCatalogSkuKey(raw.sku);
          const usageCount = Number(raw.usageCount);
          const costDisplay = formatCurrencyDisplay(raw.estimatedCost);
          const normalized = Object.assign({}, raw, {
            description,
            category,
            supplier,
            sku,
            usageCount: Number.isFinite(usageCount) && usageCount > 0 ? usageCount : 0,
            costDisplay,
            descriptionLower: description.toLowerCase()
          });
          const estimatedCostText = raw && raw.estimatedCost !== undefined && raw.estimatedCost !== null
            ? String(raw.estimatedCost)
            : '';
          const searchParts = [description, category, sku, supplier, estimatedCostText, costDisplay]
            .filter(Boolean)
            .map(part => part.toLowerCase());
          normalized.searchTarget = searchParts.join(' ');
          return normalized;
        });
      }

      function mergeCatalogItems(existing, incoming) {
        const base = Array.isArray(existing) ? existing.slice() : [];
        const additions = Array.isArray(incoming) ? incoming : [];
        if (!additions.length) {
          return base;
        }
        const positionBySku = Object.create(null);
        base.forEach((item, index) => {
          const key = makeCatalogSkuKey(item && item.sku);
          if (key) {
            positionBySku[key] = index;
          }
        });
        additions.forEach(item => {
          if (!item) {
            return;
          }
          const key = makeCatalogSkuKey(item.sku);
          if (key && positionBySku[key] !== undefined) {
            base[positionBySku[key]] = item;
          } else {
            if (key) {
              positionBySku[key] = base.length;
            }
            base.push(item);
          }
        });
        return base;
      }

      function updateCatalogIndexes() {
        const items = Array.isArray(state.catalog.items) ? state.catalog.items : [];
        const itemBySku = Object.create(null);
        const descriptionIndex = Object.create(null);
        const usageEntries = [];
        items.forEach(item => {
          if (!item) {
            return;
          }
          const key = makeCatalogSkuKey(item.sku);
          if (key) {
            itemBySku[key] = item;
            if (Number(item.usageCount) > 0) {
              usageEntries.push(item);
            }
          }
          if (item.descriptionLower && !(item.descriptionLower in descriptionIndex)) {
            descriptionIndex[item.descriptionLower] = item;
          }
        });
        usageEntries.sort((a, b) => Number(b.usageCount) - Number(a.usageCount));
        const topSkuLookup = Object.create(null);
        usageEntries.slice(0, 5).forEach(item => {
          const key = makeCatalogSkuKey(item.sku);
          if (key) {
            topSkuLookup[key] = true;
          }
        });
        state.catalog.itemBySku = itemBySku;
        state.catalog.descriptionIndex = descriptionIndex;
        state.catalog.topSkuLookup = topSkuLookup;
      }

      function getCatalogSearchTarget(item) {
        if (!item) {
          return '';
        }
        if (typeof item.searchTarget === 'string') {
          return item.searchTarget;
        }
        const description = typeof item.description === 'string' ? item.description : '';
        const category = typeof item.category === 'string' ? item.category : '';
        const supplier = typeof item.supplier === 'string' ? item.supplier : '';
        const sku = makeCatalogSkuKey(item.sku);
        const estimatedCostText = item && item.estimatedCost !== undefined && item.estimatedCost !== null
          ? String(item.estimatedCost)
          : '';
        const costDisplay = getCatalogCostDisplay(item);
        const searchParts = [description, category, sku, supplier, estimatedCostText, costDisplay]
          .filter(Boolean)
          .map(part => part.toLowerCase());
        const target = searchParts.join(' ');
        item.searchTarget = target;
        return target;
      }

      function getCatalogCostDisplay(item) {
        if (!item) {
          return '';
        }
        if (typeof item.costDisplay === 'string') {
          return item.costDisplay;
        }
        const display = formatCurrencyDisplay(item.estimatedCost);
        item.costDisplay = display;
        return display;
      }

      function findCatalogItemByDescription(description) {
        const key = typeof description === 'string' ? description.trim().toLowerCase() : '';
        if (!key) {
          return null;
        }
        const index = state.catalog.descriptionIndex || {};
        if (index[key]) {
          return index[key];
        }
        const match = state.catalog.items.find(item => item && item.descriptionLower === key);
        return match || null;
      }

      function renderCatalog() {
        dom.supplies.catalogList.textContent = '';
        if (dom.supplies.catalogOptions) {
          dom.supplies.catalogOptions.textContent = '';
        }
        let selectedSku = makeCatalogSkuKey(state.forms.supplies.catalogSku || '');
        const searchValue = state.catalog.search || '';
        dom.supplies.catalogSearch.value = searchValue;
        updateCatalogSearchAffordances();
        updateCatalogControls();

        if (!state.catalog.items.length) {
          dom.supplies.catalogSearch.disabled = !state.catalog.loading;
          if (state.catalog.loading) {
            dom.supplies.catalogList.appendChild(buildSkeletonBlock());
          } else {
            const empty = document.createElement('p');
            empty.className = 'empty';
            empty.textContent = hasServer ? 'No catalog items found.' : 'Catalog requires Google Apps Script.';
            dom.supplies.catalogList.appendChild(empty);
          }
          return;
        }

        dom.supplies.catalogSearch.disabled = false;

        const descriptionValue = (state.forms.supplies.description || '').trim();
        if (!selectedSku && descriptionValue) {
          const match = findCatalogItemByDescription(descriptionValue);
          if (match) {
            selectCatalogSku(match.sku, { updateSearch: false });
            selectedSku = makeCatalogSkuKey(match.sku);
          }
        }

        dom.supplies.catalogSku.value = selectedSku;

        const normalizedSearch = searchValue.trim().toLowerCase();
        let filteredItems = state.catalog.items.slice();
        if (normalizedSearch) {
          filteredItems = state.catalog.items.filter(item => {
            const haystack = getCatalogSearchTarget(item);
            if (!haystack) {
              return false;
            }
            return haystack.indexOf(normalizedSearch) !== -1;
          });
          const skuToHighlight = makeCatalogSkuKey(state.forms.supplies.catalogSku || '');
          if (skuToHighlight && !filteredItems.some(item => makeCatalogSkuKey(item && item.sku) === skuToHighlight)) {
            const selectedItem = findCatalogItem(skuToHighlight);
            if (selectedItem) {
              filteredItems.unshift(selectedItem);
            }
          }
        }

        if (!filteredItems.length) {
          const empty = document.createElement('p');
          empty.className = 'empty';
          if (normalizedSearch) {
            empty.textContent = state.catalog.loading && !state.catalog.fullyLoaded
              ? 'Loading more catalog items to finish your search…'
              : 'No catalog items match your search. Try another keyword.';
          } else {
            empty.textContent = hasServer ? 'No catalog items found.' : 'Catalog requires Google Apps Script.';
          }
          dom.supplies.catalogList.appendChild(empty);
          return;
        }

        const topSkuLookup = state.catalog.topSkuLookup || Object.create(null);

        if (dom.supplies.catalogOptions) {
          const datalistFragment = document.createDocumentFragment();
          const limit = 25;
          const datalistItems = filteredItems.slice(0, limit);
          if (selectedSku) {
            const selectedItem = findCatalogItem(selectedSku);
            if (selectedItem && !datalistItems.some(entry => makeCatalogSkuKey(entry && entry.sku) === selectedSku)) {
              datalistItems.unshift(selectedItem);
            }
          }
          datalistItems.slice(0, limit).forEach(item => {
            const option = document.createElement('option');
            const skuKey = makeCatalogSkuKey(item && item.sku);
            option.value = formatCatalogOptionValue(item, Boolean(topSkuLookup[skuKey]));
            option.dataset.sku = item.sku;
            option.dataset.description = item.description;
            option.dataset.category = item.category || '';
            datalistFragment.appendChild(option);
          });
          dom.supplies.catalogOptions.appendChild(datalistFragment);
        }

        const fragment = document.createDocumentFragment();
        filteredItems.forEach(item => {
          const card = document.createElement('article');
          card.className = 'catalog-item';
          const skuKey = makeCatalogSkuKey(item && item.sku);
          if (skuKey === selectedSku) {
            card.classList.add('selected');
          }
          card.tabIndex = 0;
          card.setAttribute('role', 'listitem');

          const costDisplay = getCatalogCostDisplay(item);

          const head = document.createElement('div');
          head.className = 'catalog-item-head';

          const name = document.createElement('strong');
          name.className = 'catalog-item-title';
          name.textContent = item.description;
          head.appendChild(name);

          const skuLabel = document.createElement('span');
          skuLabel.className = 'catalog-item-sku';
          skuLabel.textContent = item.sku || 'SKU pending';
          head.appendChild(skuLabel);

          card.appendChild(head);

          if (Number(item.usageCount) > 0 && Boolean(topSkuLookup[skuKey])) {
            const badge = document.createElement('span');
            badge.className = 'catalog-badge';
            badge.textContent = 'Most requested';
            card.appendChild(badge);
          }

          const info = document.createElement('div');
          info.className = 'catalog-item-info';

          if (item.category) {
            const category = document.createElement('span');
            category.className = 'meta';
            category.textContent = `Category: ${item.category}`;
            info.appendChild(category);
          }

          if (item.supplier) {
            const supplier = document.createElement('span');
            supplier.className = 'detail-line';
            supplier.textContent = `Supplier: ${item.supplier}`;
            info.appendChild(supplier);
          }

          if (costDisplay) {
            const cost = document.createElement('span');
            cost.className = 'detail-line';
            cost.textContent = `Estimated cost: ${costDisplay}`;
            info.appendChild(cost);
          }

          if (Number(item.usageCount) > 0) {
            const usage = document.createElement('span');
            usage.className = 'detail-line usage';
            usage.textContent = item.usageCount === 1 ? 'Requested 1 time' : `Requested ${item.usageCount} times`;
            info.appendChild(usage);
          }

          card.appendChild(info);
          const handleSelect = () => {
            selectCatalogSku(item.sku);
            renderCatalog();
          };
          card.addEventListener('click', () => {
            handleSelect();
          });
          card.addEventListener('keydown', evt => {
            if (evt.key === 'Enter' || evt.key === ' ') {
              evt.preventDefault();
              handleSelect();
            }
          });
          fragment.appendChild(card);
        });
        dom.supplies.catalogList.appendChild(fragment);
        if (state.catalog.loading && !state.catalog.fullyLoaded) {
          const loading = document.createElement('p');
          loading.className = 'meta';
          loading.textContent = 'Loading remaining catalog items…';
          dom.supplies.catalogList.appendChild(loading);
        }
      }

      function updateCatalogSearchAffordances() {
        if (!dom.supplies.catalogClear) {
          return;
        }
        const hasValue = Boolean(dom.supplies.catalogSearch.value);
        const hasSelection = Boolean(dom.supplies.catalogSku.value);
        dom.supplies.catalogClear.classList.toggle('visible', hasValue || hasSelection);
      }

      function selectCatalogSku(sku, options) {
        const opts = options || {};
        const skuKey = makeCatalogSkuKey(sku);
        const item = skuKey ? findCatalogItem(skuKey) : null;
        const shouldUpdateSearch = opts.updateSearch !== false;
        const searchValue = 'searchValue' in opts
          ? opts.searchValue
          : item
            ? formatCatalogOptionValue(item, false)
            : '';
        if (shouldUpdateSearch) {
          state.catalog.search = searchValue;
          dom.supplies.catalogSearch.value = searchValue;
        }
        const preserveDescription = Boolean(opts.preserveDescription);
        const nextDescription = item && !preserveDescription ? item.description : dom.supplies.description.value;
        if (item && !preserveDescription) {
          syncingCatalogToDescription = true;
          dom.supplies.description.value = item.description;
          syncingCatalogToDescription = false;
        }
        dom.supplies.catalogSku.value = skuKey;
        setFormState('supplies', { catalogSku: skuKey, description: nextDescription });
        updateCatalogSearchAffordances();
        if (opts.persist !== false) {
          persistForm('supplies');
        }
      }

      function formatCurrencyDisplay(value, decimalsHint) {
        const text = value === undefined || value === null ? '' : String(value).trim();
        if (!text) {
          return '';
        }
        const numericPart = text.replace(/[^0-9.,-]/g, '');
        if (!numericPart) {
          if (/^\$/i.test(text)) {
            return text;
          }
          if (/[A-Za-z]/.test(text) || /[^0-9.,\s-]/.test(text)) {
            return text;
          }
          return `$${text}`;
        }
        const normalized = numericPart.replace(/,/g, '');
        const amount = Number(normalized);
        if (!Number.isFinite(amount)) {
          if (/^\$/i.test(text)) {
            return text;
          }
          return `$${text}`;
        }
        const decimalMatch = normalized.match(/\.(\d+)/);
        const decimalsRaw = decimalMatch ? decimalMatch[1].length : 0;
        const safeDecimals = decimalsRaw > 0
          ? Math.min(decimalsRaw, 4)
          : (typeof decimalsHint === 'number' && decimalsHint >= 0 ? decimalsHint : 2);
        let formatted;
        try {
          formatted = amount.toLocaleString('en-US', {
            minimumFractionDigits: safeDecimals,
            maximumFractionDigits: safeDecimals
          });
        } catch (err) {
          formatted = amount.toFixed(safeDecimals);
        }
        const prefixMatch = text.match(/^[^0-9-]*/);
        const prefix = prefixMatch ? prefixMatch[0] : '';
        const suffixMatch = text.match(/[^0-9.,-]*$/);
        const suffix = suffixMatch ? suffixMatch[0] : '';
        const labelPrefix = prefix || '$';
        const labelSuffix = suffix || '';
        return `${labelPrefix}${formatted}${labelSuffix}`.trim();
      }

      function formatCatalogOptionValue(item, highlight) {
        if (!item) {
          return '';
        }
        const prefix = highlight ? '★ ' : '';
        const categoryLabel = item.category ? ` · ${item.category}` : '';
        const supplierLabel = item.supplier ? ` · ${item.supplier}` : '';
        const costDisplay = getCatalogCostDisplay(item);
        const costLabel = costDisplay ? ` (${costDisplay})` : '';
        return `${prefix}${item.description}${categoryLabel}${supplierLabel} — ${item.sku}${costLabel}`;
      }

      function findCatalogOption(value) {
        if (!dom.supplies.catalogOptions) {
          return null;
        }
        const options = Array.from(dom.supplies.catalogOptions.querySelectorAll('option'));
        return options.find(option => option.value === value) || null;
      }
      function findCatalogItem(sku) {
        const key = makeCatalogSkuKey(sku);
        if (!key) {
          return null;
        }
        const lookup = state.catalog.itemBySku || {};
        if (lookup[key]) {
          return lookup[key];
        }
        const item = state.catalog.items.find(entry => makeCatalogSkuKey(entry && entry.sku) === key);
        return item || null;
      }

      function ensureFullCatalogLoaded(options) {
        if (!hasServer) {
          return;
        }
        if (state.catalog.fullyLoaded || state.catalog.loading) {
          return;
        }
        const background = Boolean(options && options.background);
        loadCatalog({ append: false, fetchAll: true, background });
      }

      function updateCatalogControls() {
        const button = dom.supplies.catalogMore;
        if (!button) {
          return;
        }
        if (!hasServer) {
          button.hidden = true;
          return;
        }
        button.hidden = false;
        if (state.catalog.loading) {
          button.disabled = true;
          button.textContent = state.catalog.backgroundLoading
            ? 'Preparing catalog…'
            : (state.catalog.fullyLoaded ? 'Refreshing…' : 'Loading all items…');
          return;
        }
        if (state.catalog.fullyLoaded) {
          button.disabled = false;
          button.textContent = 'Refresh catalog';
        } else {
          button.disabled = false;
          button.textContent = 'Load all items';
        }
      }

      function setFormState(type, partial) {
        state.forms[type] = Object.assign({}, state.forms[type], partial);
      }

      function handleRequesterNameInput(type) {
        if (!requiresRequesterName) {
          return;
        }
        const input = dom[type] && dom[type].requesterName;
        if (!input) {
          return;
        }
        setRequesterName(input.value || '', { sourceType: type });
      }

      function setRequesterName(value, options) {
        const sourceType = options && options.sourceType;
        const skipPersist = Boolean(options && options.skipPersist);
        const text = typeof value === 'string' ? value : '';
        state.requesterName = text;
        REQUEST_KEYS.forEach(type => {
          state.forms[type] = Object.assign({}, state.forms[type], { requesterName: text });
          const input = dom[type] && dom[type].requesterName;
          if (input) {
            if (!requiresRequesterName) {
              input.value = '';
            } else if (type !== sourceType || document.activeElement !== input) {
              input.value = text;
            }
          }
          if (!skipPersist) {
            persistForm(type);
          }
        });
      }

      function initializeRequesterName() {
        if (!requiresRequesterName) {
          setRequesterName('', { skipPersist: true });
          return;
        }
        const cached = REQUEST_KEYS
          .map(type => state.forms[type] && state.forms[type].requesterName ? String(state.forms[type].requesterName) : '')
          .find(name => typeof name === 'string' && name.trim());
        if (cached) {
          setRequesterName(cached, { skipPersist: true });
        } else {
          setRequesterName('', { skipPersist: true });
        }
      }

      function configureRequesterNameRequirement() {
        if (!requiresRequesterName) {
          state.requesterName = '';
        }
        REQUEST_KEYS.forEach(type => {
          const wrapper = dom[type] && dom[type].requesterNameRow;
          const input = dom[type] && dom[type].requesterName;
          if (!wrapper || !input) {
            return;
          }
          if (requiresRequesterName) {
            wrapper.hidden = false;
            input.required = true;
            input.disabled = false;
          } else {
            wrapper.hidden = true;
            input.required = false;
            input.disabled = true;
            input.value = '';
          }
        });
      }

      function sanitizeDeviceId(value) {
        return typeof value === 'string' ? value.replace(/[^0-9A-Za-z_-]/g, '').slice(0, 80) : '';
      }

      function generateDeviceId() {
        try {
          if (window.crypto && typeof window.crypto.getRandomValues === 'function') {
            const buffer = new Uint8Array(16);
            window.crypto.getRandomValues(buffer);
            return Array.from(buffer, byte => byte.toString(16).padStart(2, '0')).join('');
          }
        } catch (err) {
          // ignore crypto errors
        }
        return `dev-${Math.random().toString(36).slice(2, 10)}${Date.now().toString(36)}`;
      }

      function ensureDeviceId() {
        if (state.deviceId) {
          return state.deviceId;
        }
        let stored = '';
        try {
          stored = localStorage.getItem(DEVICE_STORAGE_KEY) || '';
        } catch (err) {
          stored = '';
        }
        let deviceId = sanitizeDeviceId(stored);
        if (!deviceId) {
          deviceId = sanitizeDeviceId(generateDeviceId());
          if (!deviceId) {
            return '';
          }
          try {
            localStorage.setItem(DEVICE_STORAGE_KEY, deviceId);
          } catch (err) {
            // ignore storage errors
          }
        }
        state.deviceId = deviceId;
        return deviceId;
      }

      function persistForm(type, options) {
        const immediate = options && options.immediate;
        if (immediate) {
          flushPersist(type);
          return;
        }
        clearTimeout(persistTimers[type]);
        persistTimers[type] = setTimeout(() => {
          flushPersist(type);
        }, PERSIST_DELAY);
      }

      function flushPersist(type) {
        try {
          localStorage.setItem(LOCAL_KEYS[type], JSON.stringify(state.forms[type]));
        } catch (err) {
          // ignore storage errors
        }
      }

      function clearPersistedForm(type) {
        if (persistTimers[type]) {
          clearTimeout(persistTimers[type]);
          persistTimers[type] = null;
        }
        try {
          localStorage.removeItem(LOCAL_KEYS[type]);
        } catch (err) {
          // ignore storage errors
        }
      }

      function flushAllPersists() {
        REQUEST_KEYS.forEach(type => {
          if (persistTimers[type]) {
            clearTimeout(persistTimers[type]);
            persistTimers[type] = null;
          }
          flushPersist(type);
        });
      }

      function hydrateFormFromCache(type) {
        try {
          const raw = localStorage.getItem(LOCAL_KEYS[type]);
          if (raw) {
            const parsed = JSON.parse(raw);
            if (parsed && typeof parsed === 'object') {
              state.forms[type] = Object.assign({}, FORM_TEMPLATES[type], parsed);
              if (type === 'it') {
                const form = state.forms[type];
                if ((!form.urgency || form.urgency === undefined) && form.impact) {
                  form.urgency = form.impact;
                }
                delete form.impact;
                form.urgency = normalizeUrgency(form.urgency) || 'normal';
              } else if (type === 'maintenance') {
                state.forms[type].urgency = normalizeUrgency(state.forms[type].urgency) || 'normal';
              }
            }
          }
        } catch (err) {
          // ignore cache issues
        }
      }

      window.addEventListener('beforeunload', () => {
        stopDashboardAutoRefresh();
        flushAllPersists();
      });
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          flushAllPersists();
          stopDashboardAutoRefresh();
        } else if (document.visibilityState === 'visible') {
          if (hasServer) {
            requestDashboardRefresh(0);
            startDashboardAutoRefresh();
          }
        }
      });

      function resolveInitialTask(taskId) {
        if (initialLoadIndicator) {
          initialLoadIndicator.resolve(taskId);
        }
      }

      function createInitialLoadIndicator() {
        const container = document.getElementById('pageLoadingBar');
        if (!container) {
          return null;
        }
        const progress = container.querySelector('.page-loading-bar-progress');
        if (!progress) {
          return null;
        }
        const tasks = new Map();
        let totalWeight = 0;
        let completedWeight = 0;
        let visible = false;
        let hideTimer = null;
        let startTime = 0;

        function ensureVisible() {
          if (visible) {
            return;
          }
          visible = true;
          startTime = Date.now();
          container.classList.remove('is-complete');
          container.classList.add('visible');
          container.setAttribute('aria-hidden', 'false');
        }

        function scheduleHide() {
          if (!visible || hideTimer) {
            return;
          }
          const elapsed = Date.now() - startTime;
          const minVisible = 400;
          const delay = Math.max(160, minVisible - elapsed);
          hideTimer = setTimeout(() => {
            container.classList.add('is-complete');
            setTimeout(() => {
              container.classList.remove('visible');
              container.classList.remove('is-complete');
              container.setAttribute('aria-hidden', 'true');
              container.setAttribute('aria-valuenow', '0');
              progress.style.transform = 'scaleX(0)';
              visible = false;
              hideTimer = null;
            }, 320);
          }, delay);
        }

        function updateProgress() {
          if (!visible) {
            ensureVisible();
          }
          const ratio = totalWeight === 0 ? 1 : Math.min(1, completedWeight / totalWeight);
          const eased = ratio < 1 ? Math.max(0.08, ratio * 0.94) : 1;
          progress.style.transform = `scaleX(${eased})`;
          container.setAttribute('aria-valuenow', String(Math.round(ratio * 100)));
          if (ratio >= 1) {
            scheduleHide();
          }
        }

        return {
          register(id, weight = 1) {
            if (!id || tasks.has(id)) {
              return;
            }
            tasks.set(id, { weight, done: false });
            totalWeight += weight;
            if (hideTimer) {
              clearTimeout(hideTimer);
              hideTimer = null;
            }
            ensureVisible();
            updateProgress();
          },
          resolve(id) {
            const entry = tasks.get(id);
            if (!entry || entry.done) {
              return;
            }
            entry.done = true;
            completedWeight = Math.min(totalWeight, completedWeight + entry.weight);
            updateProgress();
          }
        };
      }

      function toggleRequestsSkeleton(type, active) {
        if (!active || state.requests[type].length) {
          return;
        }
        const list = dom[type].list;
        list.textContent = '';
        list.appendChild(buildSkeletonBlock());
        const moreButton = dom[type].more;
        if (moreButton) {
          moreButton.disabled = true;
        }
      }

      function toggleCatalogSkeleton(active) {
        if (!active || state.catalog.items.length) {
          return;
        }
        dom.supplies.catalogList.textContent = '';
        dom.supplies.catalogList.appendChild(buildSkeletonBlock());
        dom.supplies.catalogMore.disabled = true;
      }

      function buildSkeletonBlock() {
        const wrapper = document.createElement('div');
        wrapper.className = 'request-item';
        const title = document.createElement('div');
        title.className = 'skeleton';
        title.style.height = '20px';
        wrapper.appendChild(title);
        const line = document.createElement('div');
        line.className = 'skeleton sm';
        wrapper.appendChild(line);
        return wrapper;
      }

      function formatActorName(value) {
        const text = typeof value === 'string' ? value.trim() : '';
        if (!text) {
          return '';
        }
        const normalized = text.toLowerCase();
        if (Object.prototype.hasOwnProperty.call(EMAIL_DISPLAY_OVERRIDES, normalized)) {
          return EMAIL_DISPLAY_OVERRIDES[normalized];
        }
        return text;
      }

      function formatStatus(status) {
        switch (status) {
          case 'completed':
            return 'Completed';
          case 'in_progress':
            return 'In progress';
          case 'ordered':
            return 'Ordered';
          case 'approved':
            return 'Approved';
          case 'denied':
            return 'Denied';
          case 'declined':
            return 'Declined';
          default:
            return 'Pending review';
        }
      }

      function supportsNotes(type) {
        return NOTE_SUPPORTED_TYPES.has(type);
      }

      function getNoteDraft(type, requestId) {
        if (!supportsNotes(type)) {
          return '';
        }
        const drafts = state.noteDrafts[type];
        if (!drafts) {
          return '';
        }
        return drafts[requestId] || '';
      }

      function setNoteDraft(type, requestId, value) {
        if (!supportsNotes(type)) {
          return;
        }
        if (!state.noteDrafts[type]) {
          state.noteDrafts[type] = {};
        }
        state.noteDrafts[type][requestId] = value;
      }

      function clearNoteDraft(type, requestId) {
        if (!supportsNotes(type)) {
          return;
        }
        const drafts = state.noteDrafts[type];
        if (drafts && Object.prototype.hasOwnProperty.call(drafts, requestId)) {
          delete drafts[requestId];
        }
      }

      function formatNoteTimestamp(ts) {
        if (!ts) {
          return 'Unknown time';
        }
        const parsed = new Date(ts);
        if (!isNaN(parsed.getTime())) {
          return parsed.toLocaleString();
        }
        return ts;
      }

      function buildStatusActorLine(type, statusKey, approver) {
        const trimmedApprover = typeof approver === 'string' ? approver.trim() : '';
        const actorName = formatActorName(trimmedApprover) || 'Not recorded';
        const hasApprover = Boolean(trimmedApprover);
        switch (statusKey) {
          case 'denied':
          case 'declined':
            return `Denied by: ${actorName}`;
          case 'approved':
            return `Approved by: ${actorName}`;
          case 'ordered':
            return `Ordered by: ${actorName}`;
          case 'completed':
            return `Completed by: ${actorName}`;
          case 'in_progress':
            return `In progress by: ${actorName}`;
          case 'pending':
            return type === 'supplies' ? 'Approval decision pending' : 'Update pending';
          default:
            return `Status: ${formatStatus(statusKey)}${hasApprover ? ` by ${actorName}` : ''}`;
        }
      }

      function buildRequestNotesSection(request, type) {
        const notes = Array.isArray(request.notes) ? request.notes : [];
        const wrapper = document.createElement('section');
        wrapper.className = 'request-notes';

        const header = document.createElement('div');
        header.className = 'request-notes-header';

        const title = document.createElement('span');
        title.className = 'request-notes-title';
        title.textContent = 'Notes';
        header.appendChild(title);

        const count = document.createElement('span');
        count.className = 'request-notes-count';
        if (notes.length) {
          count.textContent = `${notes.length} ${notes.length === 1 ? 'note' : 'notes'}`;
        } else {
          count.textContent = 'No notes yet';
        }
        header.appendChild(count);

        wrapper.appendChild(header);

        const list = document.createElement('div');
        list.className = 'request-notes-list';
        if (notes.length) {
          const [latestNote, ...otherNotes] = notes;
          const latestEntry = buildRequestNoteEntry(latestNote);
          latestEntry.classList.add('request-note-latest');
          list.appendChild(latestEntry);

          if (otherNotes.length) {
            const archive = document.createElement('details');
            archive.className = 'request-notes-archive';

            const summary = document.createElement('summary');
            summary.className = 'request-notes-toggle';
            const summaryLabel = document.createElement('span');
            const additionalLabel = otherNotes.length === 1 ? 'Show 1 more note' : `Show ${otherNotes.length} more notes`;
            const collapseLabel = 'Hide additional notes';
            summaryLabel.textContent = additionalLabel;
            summary.appendChild(summaryLabel);
            archive.appendChild(summary);

            const restContainer = document.createElement('div');
            restContainer.className = 'request-notes-collapsed';

            otherNotes.forEach(note => {
              const entry = buildRequestNoteEntry(note);
              restContainer.appendChild(entry);
            });

            archive.appendChild(restContainer);

            archive.addEventListener('toggle', () => {
              summaryLabel.textContent = archive.open ? collapseLabel : additionalLabel;
            });

            list.appendChild(archive);
          }
        }

        if (!notes.length) {
          const empty = document.createElement('p');
          empty.className = 'request-notes-empty';
          empty.textContent = 'No notes yet.';
          list.appendChild(empty);
        }

        wrapper.appendChild(list);

        if (canManageStatuses) {
          const form = document.createElement('form');
          form.className = 'request-note-form';
          form.noValidate = true;

          const textarea = document.createElement('textarea');
          textarea.placeholder = 'Add a note for this request…';
          textarea.value = getNoteDraft(type, request.id);
          textarea.addEventListener('input', () => {
            setNoteDraft(type, request.id, textarea.value);
          });
          if (!server) {
            textarea.disabled = true;
          }
          form.appendChild(textarea);

          if (!server) {
            const helper = document.createElement('p');
            helper.className = 'request-note-helper';
            helper.textContent = 'Connect to Google Apps Script to add notes.';
            form.appendChild(helper);
          }

          const actions = document.createElement('div');
          actions.className = 'request-note-actions';

          const submit = document.createElement('button');
          submit.type = 'submit';
          submit.className = 'secondary';
          submit.textContent = 'Add note';
          if (!server) {
            submit.disabled = true;
          }
          actions.appendChild(submit);
          form.appendChild(actions);

          form.addEventListener('submit', event => {
            event.preventDefault();
            handleAddNote(type, request, textarea, submit);
          });

          wrapper.appendChild(form);
        }

        return wrapper;
      }

      function buildRequestNoteEntry(note) {
        const entry = document.createElement('article');
        entry.className = 'request-note';

        const meta = document.createElement('div');
        meta.className = 'request-note-meta';

        const actorText = formatActorName(note && note.actor);
        if (actorText) {
          const actor = document.createElement('span');
          actor.textContent = actorText;
          meta.appendChild(actor);
        }

        const timestampRaw = typeof note.ts === 'string' ? note.ts : '';
        const timestampLabel = timestampRaw ? formatNoteTimestamp(timestampRaw) : '';
        if (timestampLabel) {
          if (meta.childElementCount) {
            meta.appendChild(makeMetaDot());
          }
          const time = document.createElement('time');
          time.className = 'request-note-ts';
          time.dateTime = timestampRaw;
          time.textContent = timestampLabel;
          meta.appendChild(time);
        }

        if (!meta.childElementCount) {
          meta.textContent = 'Note';
        }

        entry.appendChild(meta);

        const bodyText = typeof note.note === 'string' ? note.note : '';
        if (bodyText) {
          const body = document.createElement('p');
          body.className = 'request-note-body';
          body.textContent = bodyText;
          entry.appendChild(body);
        }

        return entry;
      }

      function makeMetaDot() {
        const dot = document.createElement('span');
        dot.className = 'request-note-dot';
        dot.textContent = '•';
        dot.setAttribute('aria-hidden', 'true');
        return dot;
      }

      function disableForm(type, disabled) {
        if (type === 'supplies') {
          dom.supplies.submit.disabled = disabled;
          dom.supplies.location.disabled = disabled;
          dom.supplies.qty.disabled = disabled;
          dom.supplies.notes.disabled = disabled;
          dom.supplies.catalogSearch.disabled = disabled;
          dom.supplies.reset.disabled = disabled;
          if (dom.supplies.requesterName && requiresRequesterName) {
            dom.supplies.requesterName.disabled = disabled;
          }
        } else if (type === 'it') {
          dom.it.submit.disabled = disabled;
          dom.it.location.disabled = disabled;
          dom.it.issue.disabled = disabled;
          dom.it.device.disabled = disabled;
          dom.it.urgency.disabled = disabled;
          dom.it.details.disabled = disabled;
          dom.it.reset.disabled = disabled;
          if (dom.it.requesterName && requiresRequesterName) {
            dom.it.requesterName.disabled = disabled;
          }
        } else if (type === 'maintenance') {
          dom.maintenance.submit.disabled = disabled;
          dom.maintenance.location.disabled = disabled;
          dom.maintenance.issue.disabled = disabled;
          dom.maintenance.urgency.disabled = disabled;
          dom.maintenance.accessNotes.disabled = disabled;
          dom.maintenance.reset.disabled = disabled;
          if (dom.maintenance.requesterName && requiresRequesterName) {
            dom.maintenance.requesterName.disabled = disabled;
          }
        }
      }

      function showToast(message) {
        dom.toast.textContent = message;
        dom.toast.style.display = 'block';
        clearTimeout(showToast.timer);
        showToast.timer = setTimeout(() => {
          dom.toast.style.display = 'none';
        }, 2800);
      }

      function resolveErrorMessage(err) {
        if (!err) {
          return 'Something went wrong. Please try again.';
        }
        if (typeof err === 'string') {
          return err;
        }
        if (typeof err.message === 'string' && err.message.trim()) {
          return err.message.trim();
        }
        if (typeof err.statusText === 'string' && err.statusText.trim()) {
          return err.statusText.trim();
        }
        if (typeof err.details === 'string' && err.details.trim()) {
          return err.details.trim();
        }
        if (Array.isArray(err.details) && err.details.length) {
          const firstDetail = err.details.find(detail => typeof detail === 'string' && detail.trim());
          if (firstDetail) {
            return firstDetail.trim();
          }
        }
        if (Array.isArray(err.errors) && err.errors.length) {
          const firstError = err.errors.find(detail => typeof detail === 'string' && detail.trim());
          if (firstError) {
            return firstError.trim();
          }
        }
        if (typeof err.error === 'string' && err.error.trim()) {
          return err.error.trim();
        }
        return 'Something went wrong. Please try again.';
      }

      function handleError(err, context, payload) {
        const message = resolveErrorMessage(err);
        console.error('[RequestManager]', context, message, err);
        showToast(message);
        if (!server) {
          return;
        }
        try {
          server
            .withFailureHandler(() => { })
            .logClientError({
              cid: makeCid(),
              context,
              message,
              stack: err && err.stack ? String(err.stack) : '',
              payload
            });
        } catch (loggingError) {
          // ignore logging issues
        }
      }

      function makeCid() {
        return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
      }

      function makeClientRequestId(type) {
        return `${initialSessionEmail || 'user'}-${type}-${makeCid()}`;
      }
    })();
  </script>
<script>
    (function() {
      function sanitizeText(value) {
        if (typeof value !== 'string') {
          return '';
        }
        return value.trim();
      }

      function parseQty(value) {
        const num = Number(value);
        if (!Number.isFinite(num) || num < 1) {
          return 0;
        }
        return Math.floor(num);
      }

      const DATE_TIME_OPTIONS = Object.freeze({
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });

      function validatePayload(payload) {
        const fields = {
          description: '',
          qty: '',
          location: '',
          notes: ''
        };
        const value = {
          description: sanitizeText(payload && payload.description),
          qty: parseQty(payload && payload.qty),
          location: sanitizeText(payload && payload.location),
          notes: sanitizeText(payload && payload.notes)
        };
        if (!value.description) {
          fields.description = 'Describe what you need.';
        }
        if (!value.qty) {
          fields.qty = 'Quantity must be at least 1.';
        }
        const valid = !fields.description && !fields.qty;
        return { valid, fields, value };
      }

      function buildClientRequestId() {
        const buffer = new Uint32Array(4);
        if (window.crypto && typeof window.crypto.getRandomValues === 'function') {
          window.crypto.getRandomValues(buffer);
          return Array.from(buffer).map(num => num.toString(16).padStart(8, '0')).join('');
        }
        return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`;
      }

      function formatDate(value) {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return String(value);
        }
        try {
          return date.toLocaleString(undefined, DATE_TIME_OPTIONS);
        } catch (err) {
          return date.toLocaleString();
        }
      }

      window.RequestsAppHelpers = {
        sanitizeText,
        parseQty,
        validatePayload,
        buildClientRequestId,
        formatDate
      };
    })();
  </script>
